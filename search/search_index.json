{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"notional","text":"<p>Notional is loosely modeled after concepts found in SQLAlchemy and MongoEngine. This module is built on the notion-sdk-py library, providing higher-level access to the API.</p>"},{"location":"#developer-guides","title":"Developer Guides","text":"<ul> <li>Getting Started</li> <li>Querying the API</li> <li>Content Iterators</li> <li>Document Parsing</li> <li>Object-Relational Mapping</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<p>If you are stuck, the best place to start is the Discussion area.  Use this also as a resource for asking questions or providing suggestions.</p>"},{"location":"#known-issues","title":"Known Issues","text":"<p>See Issues on github.</p>"},{"location":"#feature-requests","title":"Feature Requests","text":"<p>See Issues on github.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Read the contributing guide.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Fork the <code>notional</code> repository into your account and clone a local working copy.</p> </li> <li> <p>Create a new feature branch for your changes.</p> </li> <li> <p>Set up a local environment.</p> <ol> <li>Create a virtual environment:</li> </ol> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <ol> <li>Install dependencies (using poetry):</li> </ol> <pre><code>poetry install\n</code></pre> <ol> <li>Install <code>pre-commit</code> hooks:</li> </ol> <pre><code>pre-commit install\n</code></pre> </li> <li> <p>Follow the standards enforced by the tools.  At any time, you may use the    <code>preflight</code> target to run the unit tests and code checks.</p> </li> <li> <p>Provide tests for new code and ensure they are passing.</p> </li> <li> <p>Submit a pull request with your changes.</p> </li> </ol>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are highly encouraged!  Please make sure the PR passes <code>pre-commit</code> prior to submission.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<p>Notional uses standard Python coding practices.</p>"},{"location":"contributing/#style","title":"Style","text":"<p>All code must be formatted using <code>black</code>.</p> <p>Additionally, all <code>import</code> statements will be sorted according to <code>isort</code>.</p>"},{"location":"contributing/#static-analysis","title":"Static Analysis","text":"<p>Code will be scanned using <code>flake8</code>.</p>"},{"location":"contributing/#unit-tests","title":"Unit Tests","text":"<p>Where practical, stand-alone unit tests ae strongly encouraged.  In the future, code coverage may be enforced for new commits.</p> <p>If it is not practical to develop a unit test, evidence of working code must be provided in the pull request.</p> <p>To run the unittests, you can set up new integration in notion, create new empty page and give integration access to the page. Then export two env variables:</p> <pre><code>export NOTION_AUTH_TOKEN=\"secret_tOkEn\"\nexport NOTION_TEST_AREA=\"TEST_PAGE_ID (not the URL)\"\n</code></pre> <p>before running the tests (<code>make unit-tests</code>). Tests are recorded by pytest-vcr, <code>make reset-vcr</code> will reset recorded data.</p>"},{"location":"contributing/#submitting-issues-requests","title":"Submitting Issues &amp; Requests","text":"<p>Please review the open issues and feature requests.  This is a great place to start if you are looking for ways to contribute!</p>"},{"location":"contributing/#known-issues","title":"Known Issues","text":"<p>See Issues on github.</p>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>See Issues on github.</p>"},{"location":"iterators/","title":"Iterators","text":"<p>The iterators provide convenient access to paginated data in the Notion API.</p> <pre><code>import notional\n\nfrom notional.iterator import EndpointIterator\n\nnotion = notional.connect(auth=NOTION_AUTH_TOKEN)\n\n# be sure to use the notion_sdk endpoint for the iterator\nquery = EndpointIterator(notion.databases().query)\n\nparams = {\n    database_id=task_db_id,\n    sorts=[\n        {\n            'direction': 'ascending',\n            'property': 'Last Update'\n        }\n    ]\n}\n\nfor data in query(**params):\n    # do the things\n</code></pre> <p>Note that the parameters to the iterator call use the standard API parameters for the endpoint.</p>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2021 Jason Heddings\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"orm/","title":"Object-Relational Mapping","text":"<p>This library has support for defining custom data types that wrap Notion pages. Typically, these pages are entries in a database (collection) with a consistent schema.</p>"},{"location":"orm/#custom-types","title":"Custom Types","text":"<p>Custom types must extend the <code>ConnectedPage</code> object.  To do so, first initialize a session and generate the page object:</p> <pre><code>auth_token = os.getenv(\"NOTION_AUTH_TOKEN\")\nnotion = notional.connect(auth=auth_token)\nCustomPage = connected_page(session=notion)\n</code></pre>"},{"location":"orm/#data-objects","title":"Data Objects","text":"<p>Users may define custom types that map to entries in a Notion database.  To accomplish this, declare a class and its members using Notional types:</p> <pre><code>class Task(CustomPage, database=NOTION_DATABASE_ID):\n    Title = Property('Title', schema.Title())\n    Priority = Property('Priority', schema.SelectOne())\n    DueDate = Property('Due Date', schema.Date())\n</code></pre> <p>Alternatively, you may set the database ID as a private member of the custom type:</p> <pre><code>class Task(CustomPage):\n    __database__ = NOTION_DATABASE_ID\n</code></pre> <p>In the examples, <code>NOTION_DATABASE_ID</code> is defined as a string or UUID of a database visible to the current integration.</p> <p>Review the <code>schema</code> reference for all available types.</p>"},{"location":"orm/#querying","title":"Querying","text":"<p>Connected pages expose a <code>query()</code> method, which returns a custom <code>QueryBuilder</code> for iterating over user-defined types:</p> <pre><code>for task in Task.query().execute():\n    print(f\"{task.Title} =&gt; {task.Priority}\")\n    task.DueDate = date.today()\n</code></pre> <p>See the examples for more information and additional usage.</p>"},{"location":"parser/","title":"Parsers","text":"<p>Notional includes several parsers for importing external content. They will accept either string (data) or file-like objects to provide the input content.</p>"},{"location":"parser/#html-parser","title":"HTML Parser","text":"<p>The HTML parser read an HTML document into Notion API objects.  From there, the caller may create a page in Notion using the rendered content.</p> <pre><code>from notional.parser import HtmlParser\n\nparser = HtmlParser(base=\"https://www.example.com/\")\n\nwith open(filename, \"r\") as fp:\n    parser.parse(fp)\n\ndoc = notion.pages.create(\n    parent=parent_page,\n    title=parser.title,\n    children=parser.content,\n)\n</code></pre> <p>Note: while the parser aims to be general purpose, there may be conditions where it cannot interpret the HTML document.  Please submit an issue if you find an example of valid HTML that is not properly converted.</p> <p>After parsing, the <code>HtmlParser</code> will contain <code>title</code>, <code>meta</code>, and <code>content</code>.</p>"},{"location":"parser/#htmlparsertitle","title":"<code>HtmlParser.title</code>","text":"<p>If the parser encounters a <code>&lt;title&gt;</code> element, this property will be set to the contents.</p> <p>Otherwise, the parser will attempt to look for a <code>name</code> in the input data stream. Typically, this would be the filename if the data is a file-like object.</p> <p>If no <code>&lt;title&gt;</code> or <code>name</code> exists, this property will be <code>None</code>.</p>"},{"location":"parser/#htmlparsermeta","title":"<code>HtmlParser.meta</code>","text":"<p>The <code>meta</code> property is a <code>dict</code> containing data from <code>&lt;meta&gt;</code> tags in the input.  This property is a <code>dict</code> where each element has the form <code>meta_name: meta_value</code>.</p>"},{"location":"parser/#htmlparsercontent","title":"<code>HtmlParser.content</code>","text":"<p>Content is rendered into a list of blocks, ready to be created or appended to a page.</p>"},{"location":"parser/#csv-parser","title":"CSV Parser","text":"<p>The CSV parser will read comma-separate value content and generate the appropriate database along with content.  In order to populate the database, the contents must be created as individual pages.</p> <pre><code>from notional.parser import CsvParser\n\nparser = CsvParser(header_row=True)\n\nwith open(filename, \"r\") as fp:\n    parser.parse(fp)\n\ndoc = notion.databases.create(\n    parent=parent_page,\n    title=parser.title,\n    schema=parser.schema,\n)\n\nfor props in parser.content:\n    page = notion.pages.create(\n        parent=db,\n        properties=props,\n    )\n</code></pre> <p>The <code>CsvParser</code> accepts the follow configuration options when initialized:</p> <ul> <li><code>header_row</code> - indicates that the input data has a header row, which will be used to   generate the schema (defaults to <code>True</code>)</li> <li><code>title_column</code> - indicates which column number to use as the title for entries   (defaults to <code>0</code>)</li> </ul> <p>After parsing, the <code>CsvParser</code> will contain <code>title</code>, <code>schema</code>, and <code>content</code>.</p>"},{"location":"parser/#csvparsertitle","title":"<code>CsvParser.title</code>","text":"<p>The parser will attempt to read a <code>name</code> property from the input data source.  As seen in the above example, this is a useful property when creating the database.</p> <p>If there is no <code>name</code> available, this property will be <code>None</code>.</p>"},{"location":"parser/#csvparserschema","title":"<code>CsvParser.schema</code>","text":"<p>The parser will generate a schema for the CSV data, which is used when creating the database.  The schema is presented as a <code>dict</code> where each element is the form <code>field_name: field_type</code> and can be passed to the <code>databases.create()</code> method.</p>"},{"location":"parser/#csvparsercontent","title":"<code>CsvParser.content</code>","text":"<p>CSV data is created as a list of page properties in the database.  The content must be created as separate pages with the new database parent.  Specifically, the <code>content</code> property is a <code>list</code> where each element is a <code>dict</code> of the form <code>field_name: field_value</code>.  These elements are a full set of properties for creating a new page.</p>"},{"location":"query/","title":"Query Builder","text":"<p>Notional provides a query builder for interacting with the Notion API.  Query targets can be either a specific database ID or a custom ORM type.</p>"},{"location":"query/#filters","title":"Filters","text":"<p>Filters can be added for either timestamps or properties using the query builder.  They operate using a set of constraints, depending on the object being filtered.  Constraints may be appended to the query builder using keywords or by creating them directly:</p> <pre><code>notion = notional.connect(auth=auth_token)\n\nquery = (\n    notion.databases.query(dbid)\n    .filter(property=\"Title\", text=TextConstraint(contains=\"project\"))\n    .filter(LastEditedTimeFilter.create(DateConstraint(past_week={})))\n    .limit(1)\n)\n\ndata = query.first()\n\n# process query result\n</code></pre>"},{"location":"query/#sorting","title":"Sorting","text":"<p>Sorts can be added to the query using the <code>sort()</code> method:</p> <pre><code>notion = notional.connect(auth=auth_token)\n\nquery = notion.databases.query(dbid).sort(\n    property=\"Title\", direction=SortDirection.ascending\n)\n\nfor data in query.execute():\n    # something magic happens\n</code></pre> <p>For more information about querying, read the official API documentation.</p>"},{"location":"start/","title":"Quick Start","text":"<p>Using Notional requires an understanding of concepts described in the Notion API.  In particular, it is important to understand authorization and the data model.</p>"},{"location":"start/#authorization","title":"Authorization","text":"<p>Obtain an authentication token from your Notion account.</p>"},{"location":"start/#token-security","title":"Token Security","text":"<p>It is generally a best practice to read the auth token from an environment variable or a secrets file.  To prevent accidental exposure, it is NOT recommended to save the token in source.</p>"},{"location":"start/#installation","title":"Installation","text":"<p>Install the most recent release using PyPI:</p> <pre><code>pip install notional\n</code></pre> <p>Note: it is recommended to use a virtual environment (<code>venv</code>) for installing libraries to prevent conflicting dependency versions.</p>"},{"location":"start/#connect","title":"Connect","text":"<p>Connect to the API using an integration token or an OAuth access token:</p> <pre><code>import notional\n\nnotion = notional.connect(auth=AUTH_TOKEN)\n</code></pre>"},{"location":"start/#data-objects","title":"Data Objects","text":"<p>The majority of the Notion API expresses capabilities through data objects that follow a specific pattern.  It is good to be familiar with the Notion API representation of these objects, as it will help understand concepts found in Notional.</p> <p>Many common uses of data objects require interacting with the internal data. Notional provides two helper methods for working with this structure: compose and call.</p>"},{"location":"start/#constructing","title":"Constructing","text":"<p>Constructing a data object requires manually setting up the internal data structures.  Consider the following example:</p> <pre><code>text = \"It was a dark and stormy night...\"\nnested = TextObject.NestedData(content=text)\nrtf = text.TextObject(text=nested, plain_text=text)\ncontent = blocks.Paragraph.NestedData(text=[rtf])\npara = blocks.Paragraph(paragraph=content)\n</code></pre> <p>Notice how we build the <code>NestedData</code> object in order to construct the final <code>Paragraph</code>.  This approach provides the most versatility when building complex objects.</p> <p>Technical note: since Notional uses <code>pydantic</code> for object serialization under the hood, the constructor for each object is generated based on the object properties.</p>"},{"location":"start/#composing","title":"Composing","text":"<p>Composing a data object provides the caller a shorthand to construction.  Rather than explicitly laying out the nested data, the <code>__compose__</code> method takes care of setting up the internal data structure.</p> <p>Consider our example from above.  Using the composable feature of a <code>Paragraph</code> block changes the code like so:</p> <pre><code>para = blocks.Paragraph[\"It was a dark and stormy night...\"]\n</code></pre> <p>Note the use of <code>[ ]</code> in the composition example...  This instructs the <code>Paragraph</code> to compose itself from the given parameters.  The acceptable parameters for this method is specific to the object being composed.</p> <p>Technical note: since the constructor is provided by <code>pydantic</code>, we do not override it.  Instead, we have chosen to provide an alternate form of creating objects.  We refer to this form as \"composing\" from basic types.</p>"},{"location":"start/#calling","title":"Calling","text":"<p>Calling a data object provides access to the underlying data structure, which typically contains the content of the object.</p> <p>For example, to get the \"checked\" state of a <code>ToDo</code> block, we can use either the nested data structure directly or call the block:</p> <pre><code>todo = blocks.ToDo(...)\n\n# direct access\nchecked = todo.to_do.checked\n\n# nested data access\nchecked = todo().checked\n\n# nested property access\nchecked = todo(\"checked\")\n</code></pre> <p>In the above example, all three approaches for getting the <code>checked</code> field of our <code>ToDo</code> block produce the same result.</p>"},{"location":"reference/","title":"Overview","text":"<p>Provide a simple ORM for Notion objects.</p>"},{"location":"reference/#notional.connect","title":"<code>connect(**kwargs)</code>","text":"<p>Connect to Notion using the provided integration token.</p> Source code in <code>src/notional/__init__.py</code> <pre><code>def connect(**kwargs):\n    \"\"\"Connect to Notion using the provided integration token.\"\"\"\n\n    logger.debug(\"connecting to Notion...\")\n\n    return Session(**kwargs)\n</code></pre>"},{"location":"reference/blocks/","title":"Blocks","text":"<p>Wrapper for Notion API blocks.</p> <p>Blocks are the base for all Notion content.</p>"},{"location":"reference/blocks/#notional.blocks.Block","title":"<code>Block</code>","text":"<p>               Bases: <code>DataRecord</code>, <code>TypedObject</code></p> <p>A standard block object in Notion.</p> <p>Calling the block will expose the nested data in the object.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Block(DataRecord, TypedObject, object=\"block\"):\n    \"\"\"A standard block object in Notion.\n\n    Calling the block will expose the nested data in the object.\n    \"\"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Bookmark","title":"<code>Bookmark</code>","text":"<p>               Bases: <code>Block</code></p> <p>A bookmark block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Bookmark(Block, type=\"bookmark\"):\n    \"\"\"A bookmark block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        url: str = None\n        caption: Optional[List[RichTextObject]] = None\n\n    bookmark: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, url):\n        \"\"\"Compose a new `Bookmark` block from a specific URL.\"\"\"\n        return Bookmark(bookmark=Bookmark._NestedData(url=url))\n\n    @property\n    def URL(self):\n        \"\"\"Return the URL contained in this `Bookmark` block.\"\"\"\n        return self.bookmark.url\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.bookmark and self.bookmark.url:\n            return f\"&lt;{self.bookmark.url}&gt;\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Bookmark.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Bookmark.URL","title":"<code>URL</code>  <code>property</code>","text":"<p>Return the URL contained in this <code>Bookmark</code> block.</p>"},{"location":"reference/blocks/#notional.blocks.Bookmark.__compose__","title":"<code>__compose__(url)</code>  <code>classmethod</code>","text":"<p>Compose a new <code>Bookmark</code> block from a specific URL.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, url):\n    \"\"\"Compose a new `Bookmark` block from a specific URL.\"\"\"\n    return Bookmark(bookmark=Bookmark._NestedData(url=url))\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Breadcrumb","title":"<code>Breadcrumb</code>","text":"<p>               Bases: <code>Block</code></p> <p>A breadcrumb block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Breadcrumb(Block, type=\"breadcrumb\"):\n    \"\"\"A breadcrumb block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        pass\n\n    breadcrumb: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.BulletedListItem","title":"<code>BulletedListItem</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A bulleted list item in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class BulletedListItem(TextBlock, WithChildrenMixin, type=\"bulleted_list_item\"):\n    \"\"\"A bulleted list item in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        children: Optional[List[Block]] = None\n        color: FullColor = FullColor.DEFAULT\n\n    bulleted_list_item: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.bulleted_list_item and self.bulleted_list_item.rich_text:\n            return f\"- {markdown(*self.bulleted_list_item.rich_text)}\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.BulletedListItem.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Callout","title":"<code>Callout</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A callout block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Callout(TextBlock, WithChildrenMixin, type=\"callout\"):\n    \"\"\"A callout block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        children: Optional[List[Block]] = None\n        icon: Optional[Union[FileObject, EmojiObject]] = None\n        color: FullColor = FullColor.GRAY_BACKGROUND\n\n    callout: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, text, emoji=None, color=FullColor.GRAY_BACKGROUND):\n        \"\"\"Compose a `Callout` block from the given text, emoji and color.\"\"\"\n\n        if emoji is not None:\n            emoji = EmojiObject[emoji]\n\n        nested = Callout._NestedData(icon=emoji, color=color)\n\n        callout = cls(callout=nested)\n        callout.concat(text)\n\n        return callout\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Callout.__compose__","title":"<code>__compose__(text, emoji=None, color=FullColor.GRAY_BACKGROUND)</code>  <code>classmethod</code>","text":"<p>Compose a <code>Callout</code> block from the given text, emoji and color.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, text, emoji=None, color=FullColor.GRAY_BACKGROUND):\n    \"\"\"Compose a `Callout` block from the given text, emoji and color.\"\"\"\n\n    if emoji is not None:\n        emoji = EmojiObject[emoji]\n\n    nested = Callout._NestedData(icon=emoji, color=color)\n\n    callout = cls(callout=nested)\n    callout.concat(text)\n\n    return callout\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.ChildDatabase","title":"<code>ChildDatabase</code>","text":"<p>               Bases: <code>Block</code></p> <p>A child database block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class ChildDatabase(Block, type=\"child_database\"):\n    \"\"\"A child database block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        title: str = None\n\n    child_database: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.ChildPage","title":"<code>ChildPage</code>","text":"<p>               Bases: <code>Block</code></p> <p>A child page block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class ChildPage(Block, type=\"child_page\"):\n    \"\"\"A child page block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        title: str = None\n\n    child_page: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Code","title":"<code>Code</code>","text":"<p>               Bases: <code>TextBlock</code></p> <p>A code block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Code(TextBlock, type=\"code\"):\n    \"\"\"A code block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        caption: List[RichTextObject] = []\n        language: CodingLanguage = CodingLanguage.PLAIN_TEXT\n\n    code: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, text, lang=CodingLanguage.PLAIN_TEXT):\n        \"\"\"Compose a `Code` block from the given text and language.\"\"\"\n        block = super().__compose__(text)\n        block.code.language = lang\n        return block\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        lang = self.code.language.value if self.code and self.code.language else \"\"\n\n        # FIXME this is not the standard way to represent code blocks in markdown...\n\n        if self.code and self.code.rich_text:\n            return f\"```{lang}\\n{markdown(*self.code.rich_text)}\\n```\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Code.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Code.__compose__","title":"<code>__compose__(text, lang=CodingLanguage.PLAIN_TEXT)</code>  <code>classmethod</code>","text":"<p>Compose a <code>Code</code> block from the given text and language.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, text, lang=CodingLanguage.PLAIN_TEXT):\n    \"\"\"Compose a `Code` block from the given text and language.\"\"\"\n    block = super().__compose__(text)\n    block.code.language = lang\n    return block\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Column","title":"<code>Column</code>","text":"<p>               Bases: <code>Block</code>, <code>WithChildrenMixin</code></p> <p>A column block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Column(Block, WithChildrenMixin, type=\"column\"):\n    \"\"\"A column block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        # note that children will not be populated when getting this block\n        # https://developers.notion.com/changelog/column-list-and-column-support\n        children: Optional[List[Block]] = None\n\n    column: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, *blocks):\n        \"\"\"Create a new `Column` block with the given blocks as children.\"\"\"\n        col = cls()\n\n        for block in blocks:\n            col.append(block)\n\n        return col\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Column.__compose__","title":"<code>__compose__(*blocks)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Column</code> block with the given blocks as children.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, *blocks):\n    \"\"\"Create a new `Column` block with the given blocks as children.\"\"\"\n    col = cls()\n\n    for block in blocks:\n        col.append(block)\n\n    return col\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.ColumnList","title":"<code>ColumnList</code>","text":"<p>               Bases: <code>Block</code>, <code>WithChildrenMixin</code></p> <p>A column list block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class ColumnList(Block, WithChildrenMixin, type=\"column_list\"):\n    \"\"\"A column list block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        # note that children will not be populated when getting this block\n        # https://developers.notion.com/changelog/column-list-and-column-support\n        children: Optional[List[Column]] = None\n\n    column_list: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, *columns):\n        \"\"\"Create a new `Column` block with the given blocks as children.\"\"\"\n        cols = cls()\n\n        for col in columns:\n            cols.append(col)\n\n        return cols\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.ColumnList.__compose__","title":"<code>__compose__(*columns)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Column</code> block with the given blocks as children.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, *columns):\n    \"\"\"Create a new `Column` block with the given blocks as children.\"\"\"\n    cols = cls()\n\n    for col in columns:\n        cols.append(col)\n\n    return cols\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.DataRecord","title":"<code>DataRecord</code>","text":"<p>               Bases: <code>NotionObject</code></p> <p>The base type for all Notion API records.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class DataRecord(NotionObject):\n    \"\"\"The base type for all Notion API records.\"\"\"\n\n    id: UUID = None\n\n    parent: ParentRef = None\n    has_children: bool = False\n\n    archived: bool = False\n\n    created_time: datetime = None\n    created_by: User = None\n\n    last_edited_time: datetime = None\n    last_edited_by: User = None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Database","title":"<code>Database</code>","text":"<p>               Bases: <code>DataRecord</code></p> <p>A database record type.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Database(DataRecord, object=\"database\"):\n    \"\"\"A database record type.\"\"\"\n\n    title: List[RichTextObject] = None\n    url: str = None\n    icon: Optional[Union[FileObject, EmojiObject]] = None\n    cover: Optional[FileObject] = None\n    properties: Dict[str, PropertyObject] = {}\n    description: Optional[List[RichTextObject]] = None\n    is_inline: bool = False\n\n    @property\n    def Title(self):\n        \"\"\"Return the title of this database as plain text.\"\"\"\n        if self.title is None or len(self.title) == 0:\n            return None\n\n        return plain_text(*self.title)\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Database.Title","title":"<code>Title</code>  <code>property</code>","text":"<p>Return the title of this database as plain text.</p>"},{"location":"reference/blocks/#notional.blocks.Divider","title":"<code>Divider</code>","text":"<p>               Bases: <code>Block</code></p> <p>A divider block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Divider(Block, type=\"divider\"):\n    \"\"\"A divider block in Notion.\"\"\"\n\n    divider: Any = {}\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n        return \"---\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Divider.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Embed","title":"<code>Embed</code>","text":"<p>               Bases: <code>Block</code></p> <p>An embed block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Embed(Block, type=\"embed\"):\n    \"\"\"An embed block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        url: str = None\n\n    embed: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, url):\n        \"\"\"Create a new `Embed` block from the given URL.\"\"\"\n        return Embed(embed=Embed._NestedData(url=url))\n\n    @property\n    def URL(self):\n        \"\"\"Return the URL contained in this `Embed` block.\"\"\"\n        return self.embed.url\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.embed and self.embed.url:\n            return f\"&lt;{self.embed.url}&gt;\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Embed.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Embed.URL","title":"<code>URL</code>  <code>property</code>","text":"<p>Return the URL contained in this <code>Embed</code> block.</p>"},{"location":"reference/blocks/#notional.blocks.Embed.__compose__","title":"<code>__compose__(url)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Embed</code> block from the given URL.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, url):\n    \"\"\"Create a new `Embed` block from the given URL.\"\"\"\n    return Embed(embed=Embed._NestedData(url=url))\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Equation","title":"<code>Equation</code>","text":"<p>               Bases: <code>Block</code></p> <p>An equation block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Equation(Block, type=\"equation\"):\n    \"\"\"An equation block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        expression: str = None\n\n    equation: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, expr):\n        \"\"\"Create a new `Equation` block from the given expression.\"\"\"\n        return LinkPreview(equation=Equation._NestedData(expression=expr))\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Equation.__compose__","title":"<code>__compose__(expr)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Equation</code> block from the given expression.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, expr):\n    \"\"\"Create a new `Equation` block from the given expression.\"\"\"\n    return LinkPreview(equation=Equation._NestedData(expression=expr))\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.File","title":"<code>File</code>","text":"<p>               Bases: <code>Block</code></p> <p>A file block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class File(Block, type=\"file\"):\n    \"\"\"A file block in Notion.\"\"\"\n\n    file: FileObject = None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Heading1","title":"<code>Heading1</code>","text":"<p>               Bases: <code>TextBlock</code></p> <p>A heading_1 block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Heading1(TextBlock, type=\"heading_1\"):\n    \"\"\"A heading_1 block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        color: FullColor = FullColor.DEFAULT\n\n    heading_1: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.heading_1 and self.heading_1.rich_text:\n            return f\"# {markdown(*self.heading_1.rich_text)} #\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Heading1.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Heading2","title":"<code>Heading2</code>","text":"<p>               Bases: <code>TextBlock</code></p> <p>A heading_2 block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Heading2(TextBlock, type=\"heading_2\"):\n    \"\"\"A heading_2 block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        color: FullColor = FullColor.DEFAULT\n\n    heading_2: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.heading_2 and self.heading_2.rich_text:\n            return f\"## {markdown(*self.heading_2.rich_text)} ##\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Heading2.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Heading3","title":"<code>Heading3</code>","text":"<p>               Bases: <code>TextBlock</code></p> <p>A heading_3 block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Heading3(TextBlock, type=\"heading_3\"):\n    \"\"\"A heading_3 block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        color: FullColor = FullColor.DEFAULT\n\n    heading_3: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.heading_3 and self.heading_3.rich_text:\n            return f\"### {markdown(*self.heading_3.rich_text)} ###\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Heading3.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Image","title":"<code>Image</code>","text":"<p>               Bases: <code>Block</code></p> <p>An image block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Image(Block, type=\"image\"):\n    \"\"\"An image block in Notion.\"\"\"\n\n    image: FileObject = None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.LinkPreview","title":"<code>LinkPreview</code>","text":"<p>               Bases: <code>Block</code></p> <p>A link_preview block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class LinkPreview(Block, type=\"link_preview\"):\n    \"\"\"A link_preview block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        url: str = None\n\n    link_preview: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, url):\n        \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\"\n        return LinkPreview(link_preview=LinkPreview._NestedData(url=url))\n\n    @property\n    def URL(self):\n        \"\"\"Return the URL contained in this `LinkPreview` block.\"\"\"\n        return self.link_preview.url\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.link_preview and self.link_preview.url:\n            return f\"&lt;{self.link_preview.url}&gt;\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.LinkPreview.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.LinkPreview.URL","title":"<code>URL</code>  <code>property</code>","text":"<p>Return the URL contained in this <code>LinkPreview</code> block.</p>"},{"location":"reference/blocks/#notional.blocks.LinkPreview.__compose__","title":"<code>__compose__(url)</code>  <code>classmethod</code>","text":"<p>Create a new <code>LinkPreview</code> block from the given URL.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, url):\n    \"\"\"Create a new `LinkPreview` block from the given URL.\"\"\"\n    return LinkPreview(link_preview=LinkPreview._NestedData(url=url))\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.LinkToPage","title":"<code>LinkToPage</code>","text":"<p>               Bases: <code>Block</code></p> <p>A link_to_page block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class LinkToPage(Block, type=\"link_to_page\"):\n    \"\"\"A link_to_page block in Notion.\"\"\"\n\n    link_to_page: ParentRef\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.NumberedListItem","title":"<code>NumberedListItem</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A numbered list item in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class NumberedListItem(TextBlock, WithChildrenMixin, type=\"numbered_list_item\"):\n    \"\"\"A numbered list item in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        children: Optional[List[Block]] = None\n        color: FullColor = FullColor.DEFAULT\n\n    numbered_list_item: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.numbered_list_item and self.numbered_list_item.rich_text:\n            return f\"1. {markdown(*self.numbered_list_item.rich_text)}\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.NumberedListItem.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.PDF","title":"<code>PDF</code>","text":"<p>               Bases: <code>Block</code></p> <p>A pdf block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class PDF(Block, type=\"pdf\"):\n    \"\"\"A pdf block in Notion.\"\"\"\n\n    pdf: FileObject = None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Page","title":"<code>Page</code>","text":"<p>               Bases: <code>DataRecord</code></p> <p>A standard Notion page object.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Page(DataRecord, object=\"page\"):\n    \"\"\"A standard Notion page object.\"\"\"\n\n    url: str = None\n    icon: Optional[Union[FileObject, EmojiObject]] = None\n    cover: Optional[FileObject] = None\n    properties: Dict[str, PropertyValue] = {}\n\n    def __getitem__(self, name):\n        \"\"\"Indexer for the given property name.\n\n        :param name: the name of the property to get from the internal properties\n        \"\"\"\n\n        prop = self.properties.get(name)\n\n        if prop is None:\n            raise AttributeError(f\"No such property: {name}\")\n\n        return prop\n\n    def __setitem__(self, name, value):\n        \"\"\"Set the object data for the given property.\n\n        If `value` is `None`, the property data will be deleted from the page.  This\n        does not affect the schema of the page, only the contents of the property.\n\n        :param name: the name of the property to set in the internal properties\n        :param value: the new value for the given property\n        \"\"\"\n\n        if value is None:\n            self.properties.pop(name, None)\n\n        elif isinstance(value, PropertyValue):\n            self.properties[name] = value\n\n        else:\n            raise ValueError(f\"Unable to set {name} :: unsupported value type\")\n\n    @property\n    def Title(self):\n        \"\"\"Return the title of this page as a string.\n\n        The title of a page is stored in its properties.  This method will examine the\n        page properties, looking for the appropriate `title` entry and return as a\n        string.\n        \"\"\"\n\n        # the 'title' property may (or may not) be indexed by name...  especially in\n        # the case of # database pages.  the only reliable way to find the title is by\n        # scanning each property.\n\n        for prop in self.properties.values():\n            if prop.id == \"title\":\n                return prop.Value\n\n        return None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Page.Title","title":"<code>Title</code>  <code>property</code>","text":"<p>Return the title of this page as a string.</p> <p>The title of a page is stored in its properties.  This method will examine the page properties, looking for the appropriate <code>title</code> entry and return as a string.</p>"},{"location":"reference/blocks/#notional.blocks.Page.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Indexer for the given property name.</p> <p>:param name: the name of the property to get from the internal properties</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def __getitem__(self, name):\n    \"\"\"Indexer for the given property name.\n\n    :param name: the name of the property to get from the internal properties\n    \"\"\"\n\n    prop = self.properties.get(name)\n\n    if prop is None:\n        raise AttributeError(f\"No such property: {name}\")\n\n    return prop\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Page.__setitem__","title":"<code>__setitem__(name, value)</code>","text":"<p>Set the object data for the given property.</p> <p>If <code>value</code> is <code>None</code>, the property data will be deleted from the page.  This does not affect the schema of the page, only the contents of the property.</p> <p>:param name: the name of the property to set in the internal properties :param value: the new value for the given property</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def __setitem__(self, name, value):\n    \"\"\"Set the object data for the given property.\n\n    If `value` is `None`, the property data will be deleted from the page.  This\n    does not affect the schema of the page, only the contents of the property.\n\n    :param name: the name of the property to set in the internal properties\n    :param value: the new value for the given property\n    \"\"\"\n\n    if value is None:\n        self.properties.pop(name, None)\n\n    elif isinstance(value, PropertyValue):\n        self.properties[name] = value\n\n    else:\n        raise ValueError(f\"Unable to set {name} :: unsupported value type\")\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Paragraph","title":"<code>Paragraph</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A paragraph block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Paragraph(TextBlock, WithChildrenMixin, type=\"paragraph\"):\n    \"\"\"A paragraph block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        children: Optional[List[Block]] = None\n        color: FullColor = FullColor.DEFAULT\n\n    paragraph: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.paragraph and self.paragraph.rich_text:\n            return markdown(*self.paragraph.rich_text)\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Paragraph.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.Quote","title":"<code>Quote</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A quote block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Quote(TextBlock, WithChildrenMixin, type=\"quote\"):\n    \"\"\"A quote block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        children: Optional[List[Block]] = None\n        color: FullColor = FullColor.DEFAULT\n\n    quote: _NestedData = _NestedData()\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.quote and self.quote.rich_text:\n            return \"&gt; \" + markdown(*self.quote.rich_text)\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Quote.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.SyncedBlock","title":"<code>SyncedBlock</code>","text":"<p>               Bases: <code>Block</code>, <code>WithChildrenMixin</code></p> <p>A synced_block block in Notion - either original or synced.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class SyncedBlock(Block, WithChildrenMixin, type=\"synced_block\"):\n    \"\"\"A synced_block block in Notion - either original or synced.\"\"\"\n\n    class _NestedData(GenericObject):\n        synced_from: Optional[BlockRef] = None\n        children: Optional[List[Block]] = None\n\n    synced_block: _NestedData = _NestedData()\n\n    @property\n    def IsOriginal(self):\n        \"\"\"Determine if this block represents the original content.\n\n        If this method returns `False`, the block represents the sync'ed block.\n        \"\"\"\n        return self.synced_block.synced_from is None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.SyncedBlock.IsOriginal","title":"<code>IsOriginal</code>  <code>property</code>","text":"<p>Determine if this block represents the original content.</p> <p>If this method returns <code>False</code>, the block represents the sync'ed block.</p>"},{"location":"reference/blocks/#notional.blocks.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>Block</code>, <code>WithChildrenMixin</code></p> <p>A table block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Table(Block, WithChildrenMixin, type=\"table\"):\n    \"\"\"A table block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        table_width: int = 0\n        has_column_header: bool = False\n        has_row_header: bool = False\n\n        # note that children will not be populated when getting this block\n        # https://developers.notion.com/reference/block#table-blocks\n        children: Optional[List[TableRow]] = []\n\n    table: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, *rows):\n        \"\"\"Create a new `Table` block with the given rows.\"\"\"\n        table = cls()\n\n        for row in rows:\n            table.append(row)\n\n        return table\n\n    def append(self, block: TableRow):\n        \"\"\"Append the given row to this table.\n\n        This method is only applicable when creating a new `Table` block.  In order to\n        add rows to an existing `Table`, use the `blocks.children.append()` endpoint.\n\n        When adding a row, this method will rase an exception if the width does not\n        match the expected number of cells for existing rows in the block.\n        \"\"\"\n\n        # XXX need to review whether this is applicable during update...  may need\n        # to raise an error if the block has already been created on the server\n\n        if not isinstance(block, TableRow):\n            raise ValueError(\"Only TableRow may be appended to Table blocks.\")\n\n        if self.Width == 0:\n            self.table.table_width = block.Width\n        elif self.Width != block.Width:\n            raise ValueError(\"Number of cells in row must match table\")\n\n        self.table.children.append(block)\n\n    @property\n    def Width(self):\n        \"\"\"Return the current width of this table.\"\"\"\n        return self.table.table_width\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Table.Width","title":"<code>Width</code>  <code>property</code>","text":"<p>Return the current width of this table.</p>"},{"location":"reference/blocks/#notional.blocks.Table.__compose__","title":"<code>__compose__(*rows)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Table</code> block with the given rows.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, *rows):\n    \"\"\"Create a new `Table` block with the given rows.\"\"\"\n    table = cls()\n\n    for row in rows:\n        table.append(row)\n\n    return table\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Table.append","title":"<code>append(block)</code>","text":"<p>Append the given row to this table.</p> <p>This method is only applicable when creating a new <code>Table</code> block.  In order to add rows to an existing <code>Table</code>, use the <code>blocks.children.append()</code> endpoint.</p> <p>When adding a row, this method will rase an exception if the width does not match the expected number of cells for existing rows in the block.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def append(self, block: TableRow):\n    \"\"\"Append the given row to this table.\n\n    This method is only applicable when creating a new `Table` block.  In order to\n    add rows to an existing `Table`, use the `blocks.children.append()` endpoint.\n\n    When adding a row, this method will rase an exception if the width does not\n    match the expected number of cells for existing rows in the block.\n    \"\"\"\n\n    # XXX need to review whether this is applicable during update...  may need\n    # to raise an error if the block has already been created on the server\n\n    if not isinstance(block, TableRow):\n        raise ValueError(\"Only TableRow may be appended to Table blocks.\")\n\n    if self.Width == 0:\n        self.table.table_width = block.Width\n    elif self.Width != block.Width:\n        raise ValueError(\"Number of cells in row must match table\")\n\n    self.table.children.append(block)\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TableOfContents","title":"<code>TableOfContents</code>","text":"<p>               Bases: <code>Block</code></p> <p>A table_of_contents block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class TableOfContents(Block, type=\"table_of_contents\"):\n    \"\"\"A table_of_contents block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        color: FullColor = FullColor.DEFAULT\n\n    table_of_contents: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TableRow","title":"<code>TableRow</code>","text":"<p>               Bases: <code>Block</code></p> <p>A table_row block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class TableRow(Block, type=\"table_row\"):\n    \"\"\"A table_row block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        cells: List[List[RichTextObject]] = None\n\n        def __getitem__(self, col):\n            \"\"\"Return the cell content for the requested column.\n\n            This will raise an `IndexError` if there are not enough columns.\n            \"\"\"\n            if col &gt; len(self.cells):\n                raise IndexError()\n\n            return self.cells[col]\n\n    table_row: _NestedData = _NestedData()\n\n    def __getitem__(self, cell_num):\n        \"\"\"Return the cell content for the requested column.\"\"\"\n        return self.table_row[cell_num]\n\n    @classmethod\n    def __compose__(cls, *cells):\n        \"\"\"Create a new `TableRow` block with the given cell contents.\"\"\"\n        row = cls()\n\n        for cell in cells:\n            row.append(cell)\n\n        return row\n\n    def append(self, text):\n        \"\"\"Append the given text as a new cell in this `TableRow`.\n\n        `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s.\n\n        :param text: the text content to append\n        \"\"\"\n        if self.table_row.cells is None:\n            self.table_row.cells = []\n\n        if isinstance(text, list):\n            self.table_row.cells.append(list)\n\n        elif isinstance(text, RichTextObject):\n            self.table_row.cells.append([text])\n\n        else:\n            rtf = TextObject[text]\n            self.table_row.cells.append([rtf])\n\n    @property\n    def Width(self):\n        \"\"\"Return the width (number of cells) in this `TableRow`.\"\"\"\n        return len(self.table_row.cells) if self.table_row.cells else 0\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TableRow.Width","title":"<code>Width</code>  <code>property</code>","text":"<p>Return the width (number of cells) in this <code>TableRow</code>.</p>"},{"location":"reference/blocks/#notional.blocks.TableRow.__compose__","title":"<code>__compose__(*cells)</code>  <code>classmethod</code>","text":"<p>Create a new <code>TableRow</code> block with the given cell contents.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, *cells):\n    \"\"\"Create a new `TableRow` block with the given cell contents.\"\"\"\n    row = cls()\n\n    for cell in cells:\n        row.append(cell)\n\n    return row\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TableRow.__getitem__","title":"<code>__getitem__(cell_num)</code>","text":"<p>Return the cell content for the requested column.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def __getitem__(self, cell_num):\n    \"\"\"Return the cell content for the requested column.\"\"\"\n    return self.table_row[cell_num]\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TableRow.append","title":"<code>append(text)</code>","text":"<p>Append the given text as a new cell in this <code>TableRow</code>.</p> <p><code>text</code> may be a string, <code>RichTextObject</code> or a list of <code>RichTextObject</code>'s.</p> <p>:param text: the text content to append</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def append(self, text):\n    \"\"\"Append the given text as a new cell in this `TableRow`.\n\n    `text` may be a string, `RichTextObject` or a list of `RichTextObject`'s.\n\n    :param text: the text content to append\n    \"\"\"\n    if self.table_row.cells is None:\n        self.table_row.cells = []\n\n    if isinstance(text, list):\n        self.table_row.cells.append(list)\n\n    elif isinstance(text, RichTextObject):\n        self.table_row.cells.append([text])\n\n    else:\n        rtf = TextObject[text]\n        self.table_row.cells.append([rtf])\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Template","title":"<code>Template</code>","text":"<p>               Bases: <code>Block</code>, <code>WithChildrenMixin</code></p> <p>A template block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Template(Block, WithChildrenMixin, type=\"template\"):\n    \"\"\"A template block in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: Optional[List[RichTextObject]] = None\n        children: Optional[List[Block]] = None\n\n    template: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TextBlock","title":"<code>TextBlock</code>","text":"<p>               Bases: <code>Block</code>, <code>ABC</code></p> <p>A standard text block object in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class TextBlock(Block, ABC):\n    \"\"\"A standard text block object in Notion.\"\"\"\n\n    # text blocks have a nested object with 'type' name and a 'rich_text' child\n\n    @property\n    def __text__(self):\n        \"\"\"Provide shorthand access to the nested text content in this block.\"\"\"\n\n        return self(\"rich_text\")\n\n    @classmethod\n    def __compose__(cls, *text):\n        \"\"\"Compose a `TextBlock` from the given text items.\"\"\"\n\n        obj = cls()\n        obj.concat(*text)\n\n        return obj\n\n    def concat(self, *text):\n        \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\"\n\n        rtf = rich_text(*text)\n\n        # calling the block returns the nested data...  this helps deal with\n        # sublcasses of `TextBlock` that each have different \"type\" attributes\n        nested = self()\n        nested.rich_text.extend(rtf)\n\n    @property\n    def PlainText(self):\n        \"\"\"Return the contents of this Block as plain text.\"\"\"\n\n        content = self.__text__\n\n        return None if content is None else plain_text(*content)\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TextBlock.PlainText","title":"<code>PlainText</code>  <code>property</code>","text":"<p>Return the contents of this Block as plain text.</p>"},{"location":"reference/blocks/#notional.blocks.TextBlock.__text__","title":"<code>__text__</code>  <code>property</code>","text":"<p>Provide shorthand access to the nested text content in this block.</p>"},{"location":"reference/blocks/#notional.blocks.TextBlock.__compose__","title":"<code>__compose__(*text)</code>  <code>classmethod</code>","text":"<p>Compose a <code>TextBlock</code> from the given text items.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, *text):\n    \"\"\"Compose a `TextBlock` from the given text items.\"\"\"\n\n    obj = cls()\n    obj.concat(*text)\n\n    return obj\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.TextBlock.concat","title":"<code>concat(*text)</code>","text":"<p>Concatenate text (either <code>RichTextObject</code> or <code>str</code> items) to this block.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def concat(self, *text):\n    \"\"\"Concatenate text (either `RichTextObject` or `str` items) to this block.\"\"\"\n\n    rtf = rich_text(*text)\n\n    # calling the block returns the nested data...  this helps deal with\n    # sublcasses of `TextBlock` that each have different \"type\" attributes\n    nested = self()\n    nested.rich_text.extend(rtf)\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.ToDo","title":"<code>ToDo</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A todo list item in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class ToDo(TextBlock, WithChildrenMixin, type=\"to_do\"):\n    \"\"\"A todo list item in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        checked: bool = False\n        children: Optional[List[Block]] = None\n        color: FullColor = FullColor.DEFAULT\n\n    to_do: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, text, checked=False, href=None):\n        \"\"\"Compose a ToDo block from the given text and checked state.\"\"\"\n        return ToDo(\n            to_do=ToDo._NestedData(\n                rich_text=[TextObject[text, href]],\n                checked=checked,\n            )\n        )\n\n    @property\n    def IsChecked(self):\n        \"\"\"Determine if this ToDo is marked as checked or not.\n\n        If the block is empty (e.g. no nested data), this method returns `None`.\n        \"\"\"\n        return self.to_do.checked if self.to_do else None\n\n    @property\n    def Markdown(self):\n        \"\"\"Return the contents of this block as markdown text.\"\"\"\n\n        if self.to_do and self.to_do.rich_text:\n            if self.to_do.checked:\n                return f\"- [x] {markdown(*self.to_do.rich_text)}\"\n\n            return f\"- [ ] {markdown(*self.to_do.rich_text)}\"\n\n        return \"\"\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.ToDo.IsChecked","title":"<code>IsChecked</code>  <code>property</code>","text":"<p>Determine if this ToDo is marked as checked or not.</p> <p>If the block is empty (e.g. no nested data), this method returns <code>None</code>.</p>"},{"location":"reference/blocks/#notional.blocks.ToDo.Markdown","title":"<code>Markdown</code>  <code>property</code>","text":"<p>Return the contents of this block as markdown text.</p>"},{"location":"reference/blocks/#notional.blocks.ToDo.__compose__","title":"<code>__compose__(text, checked=False, href=None)</code>  <code>classmethod</code>","text":"<p>Compose a ToDo block from the given text and checked state.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>@classmethod\ndef __compose__(cls, text, checked=False, href=None):\n    \"\"\"Compose a ToDo block from the given text and checked state.\"\"\"\n    return ToDo(\n        to_do=ToDo._NestedData(\n            rich_text=[TextObject[text, href]],\n            checked=checked,\n        )\n    )\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Toggle","title":"<code>Toggle</code>","text":"<p>               Bases: <code>TextBlock</code>, <code>WithChildrenMixin</code></p> <p>A toggle list item in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Toggle(TextBlock, WithChildrenMixin, type=\"toggle\"):\n    \"\"\"A toggle list item in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        rich_text: List[RichTextObject] = []\n        children: Optional[List[Block]] = None\n        color: FullColor = FullColor.DEFAULT\n\n    toggle: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.UnsupportedBlock","title":"<code>UnsupportedBlock</code>","text":"<p>               Bases: <code>Block</code></p> <p>A placeholder for unsupported blocks in the API.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class UnsupportedBlock(Block, type=\"unsupported\"):\n    \"\"\"A placeholder for unsupported blocks in the API.\"\"\"\n\n    class _NestedData(GenericObject):\n        pass\n\n    unsupported: Optional[_NestedData] = None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.Video","title":"<code>Video</code>","text":"<p>               Bases: <code>Block</code></p> <p>A video block in Notion.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class Video(Block, type=\"video\"):\n    \"\"\"A video block in Notion.\"\"\"\n\n    video: FileObject = None\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin","title":"<code>WithChildrenMixin</code>","text":"<p>Mixin for blocks that support children blocks.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>class WithChildrenMixin:\n    \"\"\"Mixin for blocks that support children blocks.\"\"\"\n\n    @property\n    def __children__(self):\n        \"\"\"Provide short-hand access to the children in this block.\"\"\"\n\n        return self(\"children\")\n\n    def __iadd__(self, block):\n        \"\"\"Append the given block to the children of this parent in place.\"\"\"\n        self.append(block)\n        return self\n\n    def append(self, block):\n        \"\"\"Append the given block to the children of this parent.\"\"\"\n\n        if block is None:\n            raise ValueError(\"block cannot be None\")\n\n        nested = self()\n\n        if nested.children is None:\n            nested.children = []\n\n        nested.children.append(block)\n\n        self.has_children = True\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin.__children__","title":"<code>__children__</code>  <code>property</code>","text":"<p>Provide short-hand access to the children in this block.</p>"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin.__iadd__","title":"<code>__iadd__(block)</code>","text":"<p>Append the given block to the children of this parent in place.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def __iadd__(self, block):\n    \"\"\"Append the given block to the children of this parent in place.\"\"\"\n    self.append(block)\n    return self\n</code></pre>"},{"location":"reference/blocks/#notional.blocks.WithChildrenMixin.append","title":"<code>append(block)</code>","text":"<p>Append the given block to the children of this parent.</p> Source code in <code>src/notional/blocks.py</code> <pre><code>def append(self, block):\n    \"\"\"Append the given block to the children of this parent.\"\"\"\n\n    if block is None:\n        raise ValueError(\"block cannot be None\")\n\n    nested = self()\n\n    if nested.children is None:\n        nested.children = []\n\n    nested.children.append(block)\n\n    self.has_children = True\n</code></pre>"},{"location":"reference/core/","title":"Core","text":"<p>Base classes for working with the Notion API.</p>"},{"location":"reference/core/#notional.core.ComposableObjectMeta","title":"<code>ComposableObjectMeta</code>","text":"<p>               Bases: <code>ModelMetaclass</code></p> <p>Presents a metaclass that composes objects using simple values.</p> <p>This is primarily to allow easy definition of data objects without disrupting the <code>BaseModel</code> constructor.  e.g. rather than requiring a caller to understand how nested data works in the data objects, they can compose objects from simple values.</p> <p>Compare the following code for declaring a Paragraph:</p> <pre><code># using nested data objects:\ntext = \"hello world\"\nnested = TextObject._NestedData(content=text)\nrtf = text.TextObject(text=nested, plain_text=text)\ncontent = blocks.Paragraph._NestedData(text=[rtf])\npara = blocks.Paragraph(paragraph=content)\n\n# using a composable object:\npara = blocks.Paragraph[\"hello world\"]\n</code></pre> <p>Classes that support composition in this way must define and implement the internal <code>__compose__</code> method.  This method takes an arbitrary number of parameters, based on the needs of the implementation.  It is up to the implementing class to ensure that the parameters are specified correctly.</p> Source code in <code>src/notional/core.py</code> <pre><code>class ComposableObjectMeta(ModelMetaclass):\n    \"\"\"Presents a metaclass that composes objects using simple values.\n\n    This is primarily to allow easy definition of data objects without disrupting the\n    `BaseModel` constructor.  e.g. rather than requiring a caller to understand how\n    nested data works in the data objects, they can compose objects from simple values.\n\n    Compare the following code for declaring a Paragraph:\n\n    ```python\n    # using nested data objects:\n    text = \"hello world\"\n    nested = TextObject._NestedData(content=text)\n    rtf = text.TextObject(text=nested, plain_text=text)\n    content = blocks.Paragraph._NestedData(text=[rtf])\n    para = blocks.Paragraph(paragraph=content)\n\n    # using a composable object:\n    para = blocks.Paragraph[\"hello world\"]\n    ```\n\n    Classes that support composition in this way must define and implement the internal\n    `__compose__` method.  This method takes an arbitrary number of parameters, based\n    on the needs of the implementation.  It is up to the implementing class to ensure\n    that the parameters are specified correctly.\n    \"\"\"\n\n    def __getitem__(self, params):\n        \"\"\"Return the requested class by composing using the given param.\n\n        Types found in `params` will be compared to expected types in the `__compose__`\n        method.\n\n        If the requested class does not expose the `__compose__` method, this will raise\n        an exception.\n        \"\"\"\n\n        if not hasattr(self, \"__compose__\"):\n            raise NotImplementedError(f\"{self} does not support object composition\")\n\n        compose_func = self.__compose__\n\n        # __getitem__ only accepts a single parameter...  if the caller provides\n        # multiple params, they will be converted and passed as a tuple.  this method\n        # also accepts a list for readability when composing from ORM properties\n\n        if params and type(params) in (list, tuple):\n            return compose_func(*params)\n\n        return compose_func(params)\n</code></pre>"},{"location":"reference/core/#notional.core.ComposableObjectMeta.__getitem__","title":"<code>__getitem__(params)</code>","text":"<p>Return the requested class by composing using the given param.</p> <p>Types found in <code>params</code> will be compared to expected types in the <code>__compose__</code> method.</p> <p>If the requested class does not expose the <code>__compose__</code> method, this will raise an exception.</p> Source code in <code>src/notional/core.py</code> <pre><code>def __getitem__(self, params):\n    \"\"\"Return the requested class by composing using the given param.\n\n    Types found in `params` will be compared to expected types in the `__compose__`\n    method.\n\n    If the requested class does not expose the `__compose__` method, this will raise\n    an exception.\n    \"\"\"\n\n    if not hasattr(self, \"__compose__\"):\n        raise NotImplementedError(f\"{self} does not support object composition\")\n\n    compose_func = self.__compose__\n\n    # __getitem__ only accepts a single parameter...  if the caller provides\n    # multiple params, they will be converted and passed as a tuple.  this method\n    # also accepts a list for readability when composing from ORM properties\n\n    if params and type(params) in (list, tuple):\n        return compose_func(*params)\n\n    return compose_func(params)\n</code></pre>"},{"location":"reference/core/#notional.core.GenericObject","title":"<code>GenericObject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The base for all API objects.</p> <p>As a general convention, data fields in lower case are defined by the Notion API.  Properties in Title Case are provided for convenience.</p> Source code in <code>src/notional/core.py</code> <pre><code>class GenericObject(BaseModel, metaclass=ComposableObjectMeta):\n    \"\"\"The base for all API objects.\n\n    As a general convention, data fields in lower case are defined by the\n    Notion API.  Properties in Title Case are provided for convenience.\n    \"\"\"\n\n    def __setattr__(self, name, value):\n        \"\"\"Set the attribute of this object to a given value.\n\n        The implementation of `BaseModel.__setattr__` does not support property setters.\n\n        See https://github.com/samuelcolvin/pydantic/issues/1577\n        \"\"\"\n        try:\n            super().__setattr__(name, value)\n        except ValueError as err:\n            setters = inspect.getmembers(\n                object=self.__class__,\n                predicate=lambda x: isinstance(x, property) and x.fset is not None,\n            )\n            for setter_name, _ in setters:\n                if setter_name == name:\n                    object.__setattr__(self, name, value)\n                    break\n            else:\n                raise err\n\n    @classmethod\n    def _set_field_default(cls, name, default=None):\n        \"\"\"Modify the `BaseModel` field information for a specific class instance.\n\n        This is necessary in particular for subclasses that change the default values\n        of a model when defined.  Notable examples are `TypedObject` and `NotionObject`.\n\n        :param name: the named attribute in the class\n        :param default: the new default for the named field\n        \"\"\"\n\n        # set the attribute on the class to the given default\n        setattr(cls, name, default)\n\n        # update the model field definition\n        field = cls.__fields__.get(name)\n\n        field.default = default\n        field.required = default is None\n\n    # https://github.com/samuelcolvin/pydantic/discussions/3139\n    def refresh(__notional_self__, **data):\n        \"\"\"Refresh the internal attributes with new data.\"\"\"\n\n        values, fields, error = validate_model(__notional_self__.__class__, data)\n\n        if error:\n            raise error\n\n        for name in fields:\n            value = values[name]\n            logger.debug(\"set object data -- %s =&gt; %s\", name, value)\n            setattr(__notional_self__, name, value)\n\n        return __notional_self__\n\n    def dict(self, **kwargs):\n        \"\"\"Convert to a suitable representation for the Notion API.\"\"\"\n\n        # the API doesn't like \"undefined\" values...\n        kwargs[\"exclude_none\"] = True\n        kwargs[\"by_alias\"] = True\n\n        obj = super().dict(**kwargs)\n\n        # TODO read-only fields should not be sent to the API\n        # https://github.com/jheddings/notional/issues/9\n\n        return serialize_to_api(obj)\n</code></pre>"},{"location":"reference/core/#notional.core.GenericObject.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Set the attribute of this object to a given value.</p> <p>The implementation of <code>BaseModel.__setattr__</code> does not support property setters.</p> <p>See https://github.com/samuelcolvin/pydantic/issues/1577</p> Source code in <code>src/notional/core.py</code> <pre><code>def __setattr__(self, name, value):\n    \"\"\"Set the attribute of this object to a given value.\n\n    The implementation of `BaseModel.__setattr__` does not support property setters.\n\n    See https://github.com/samuelcolvin/pydantic/issues/1577\n    \"\"\"\n    try:\n        super().__setattr__(name, value)\n    except ValueError as err:\n        setters = inspect.getmembers(\n            object=self.__class__,\n            predicate=lambda x: isinstance(x, property) and x.fset is not None,\n        )\n        for setter_name, _ in setters:\n            if setter_name == name:\n                object.__setattr__(self, name, value)\n                break\n        else:\n            raise err\n</code></pre>"},{"location":"reference/core/#notional.core.GenericObject.dict","title":"<code>dict(**kwargs)</code>","text":"<p>Convert to a suitable representation for the Notion API.</p> Source code in <code>src/notional/core.py</code> <pre><code>def dict(self, **kwargs):\n    \"\"\"Convert to a suitable representation for the Notion API.\"\"\"\n\n    # the API doesn't like \"undefined\" values...\n    kwargs[\"exclude_none\"] = True\n    kwargs[\"by_alias\"] = True\n\n    obj = super().dict(**kwargs)\n\n    # TODO read-only fields should not be sent to the API\n    # https://github.com/jheddings/notional/issues/9\n\n    return serialize_to_api(obj)\n</code></pre>"},{"location":"reference/core/#notional.core.GenericObject.refresh","title":"<code>refresh(__notional_self__, **data)</code>","text":"<p>Refresh the internal attributes with new data.</p> Source code in <code>src/notional/core.py</code> <pre><code>def refresh(__notional_self__, **data):\n    \"\"\"Refresh the internal attributes with new data.\"\"\"\n\n    values, fields, error = validate_model(__notional_self__.__class__, data)\n\n    if error:\n        raise error\n\n    for name in fields:\n        value = values[name]\n        logger.debug(\"set object data -- %s =&gt; %s\", name, value)\n        setattr(__notional_self__, name, value)\n\n    return __notional_self__\n</code></pre>"},{"location":"reference/core/#notional.core.NotionObject","title":"<code>NotionObject</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>A top-level Notion API resource.</p> Source code in <code>src/notional/core.py</code> <pre><code>class NotionObject(GenericObject):\n    \"\"\"A top-level Notion API resource.\"\"\"\n\n    object: str\n    id: Optional[UUID] = None\n\n    def __init_subclass__(cls, object=None, **kwargs):\n        \"\"\"Update `GenericObject` defaults for the named object.\"\"\"\n        super().__init_subclass__(**kwargs)\n\n        if object is not None:\n            cls._set_field_default(\"object\", default=object)\n\n    @validator(\"object\", always=True, pre=False)\n    def _verify_object_matches_expected(cls, val):\n        \"\"\"Make sure that the deserialzied object matches the name in this class.\"\"\"\n\n        if val != cls.object:\n            raise ValueError(f\"Invalid object for {cls.object} - {val}\")\n\n        return val\n</code></pre>"},{"location":"reference/core/#notional.core.NotionObject.__init_subclass__","title":"<code>__init_subclass__(object=None, **kwargs)</code>","text":"<p>Update <code>GenericObject</code> defaults for the named object.</p> Source code in <code>src/notional/core.py</code> <pre><code>def __init_subclass__(cls, object=None, **kwargs):\n    \"\"\"Update `GenericObject` defaults for the named object.\"\"\"\n    super().__init_subclass__(**kwargs)\n\n    if object is not None:\n        cls._set_field_default(\"object\", default=object)\n</code></pre>"},{"location":"reference/core/#notional.core.TypedObject","title":"<code>TypedObject</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>A type-referenced object.</p> <p>Many objects in the Notion API follow a standard pattern with a 'type' property followed by additional data.  These objects must specify a <code>type</code> attribute to ensure that the correct object is created.</p> <p>For example, this contains a nested 'detail' object:</p> <pre><code>data = {\n    type: \"detail\",\n    ...\n    detail: {\n        ...\n    }\n}\n</code></pre> <p>Calling the object provides direct access to the data stored in <code>{type}</code>.</p> Source code in <code>src/notional/core.py</code> <pre><code>class TypedObject(GenericObject):\n    \"\"\"A type-referenced object.\n\n    Many objects in the Notion API follow a standard pattern with a 'type' property\n    followed by additional data.  These objects must specify a `type` attribute to\n    ensure that the correct object is created.\n\n    For example, this contains a nested 'detail' object:\n\n        data = {\n            type: \"detail\",\n            ...\n            detail: {\n                ...\n            }\n        }\n\n    Calling the object provides direct access to the data stored in `{type}`.\n    \"\"\"\n\n    type: str\n\n    # modified from the methods described in this discussion:\n    # - https://github.com/samuelcolvin/pydantic/discussions/3091\n\n    def __init_subclass__(cls, type=None, **kwargs):\n        \"\"\"Register the subtypes of the TypedObject subclass.\"\"\"\n        super().__init_subclass__(**kwargs)\n\n        type_name = cls.__name__ if type is None else type\n\n        cls._register_type(type_name)\n\n    def __call__(self, field=None):\n        \"\"\"Return the nested data object contained by this `TypedObject`.\n\n        If a field is provided, the contents of that field in the nested data will be\n        returned.  Otherwise, the full contents of the NestedData will be returned.\n        \"\"\"\n\n        type = getattr(self, \"type\", None)\n\n        if type is None:\n            raise AttributeError(\"type not specified\")\n\n        nested = getattr(self, type)\n\n        if field is not None:\n            nested = getattr(nested, field)\n\n        return nested\n\n    @classmethod\n    def __get_validators__(cls):\n        \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\"\n        yield cls._resolve_type\n\n    @classmethod\n    def parse_obj(cls, obj):\n        \"\"\"Parse the structured object data into an instance of `TypedObject`.\n\n        This method overrides `BaseModel.parse_obj()`.\n        \"\"\"\n        return cls._resolve_type(obj)\n\n    @classmethod\n    def _register_type(cls, name):\n        \"\"\"Register a specific class for the given 'type' name.\"\"\"\n\n        cls._set_field_default(\"type\", default=name)\n\n        # initialize a __notional_typemap__ map for each direct child of TypedObject\n\n        # this allows different class trees to have the same 'type' name\n        # but point to a different object (e.g. the 'date' type may have\n        # different implementations depending where it is used in the API)\n\n        if not hasattr(cls, \"__notional_typemap__\"):\n            cls.__notional_typemap__ = {}\n\n        if name in cls.__notional_typemap__:\n            raise ValueError(f\"Duplicate subtype for class - {name} :: {cls}\")\n\n        logger.debug(\"registered new subtype: %s =&gt; %s\", name, cls)\n\n        cls.__notional_typemap__[name] = cls\n\n    @classmethod\n    def _resolve_type(cls, data):\n        \"\"\"Instantiate the correct object based on the 'type' field.\"\"\"\n\n        if isinstance(data, cls):\n            return data\n\n        if not isinstance(data, dict):\n            raise ValueError(\"Invalid 'data' object\")\n\n        if not hasattr(cls, \"__notional_typemap__\"):\n            raise TypeError(f\"Missing '__notional_typemap__' in {cls}\")\n\n        type_name = data.get(\"type\")\n\n        if type_name is None:\n            raise ValueError(\"Missing 'type' in data\")\n\n        sub = cls.__notional_typemap__.get(type_name)\n\n        if sub is None:\n            raise TypeError(f\"Unsupported sub-type: {type_name}\")\n\n        logger.debug(\n            \"initializing typed object %s :: %s =&gt; %s -- %s\", cls, type_name, sub, data\n        )\n\n        return sub(**data)\n</code></pre>"},{"location":"reference/core/#notional.core.TypedObject.__call__","title":"<code>__call__(field=None)</code>","text":"<p>Return the nested data object contained by this <code>TypedObject</code>.</p> <p>If a field is provided, the contents of that field in the nested data will be returned.  Otherwise, the full contents of the NestedData will be returned.</p> Source code in <code>src/notional/core.py</code> <pre><code>def __call__(self, field=None):\n    \"\"\"Return the nested data object contained by this `TypedObject`.\n\n    If a field is provided, the contents of that field in the nested data will be\n    returned.  Otherwise, the full contents of the NestedData will be returned.\n    \"\"\"\n\n    type = getattr(self, \"type\", None)\n\n    if type is None:\n        raise AttributeError(\"type not specified\")\n\n    nested = getattr(self, type)\n\n    if field is not None:\n        nested = getattr(nested, field)\n\n    return nested\n</code></pre>"},{"location":"reference/core/#notional.core.TypedObject.__get_validators__","title":"<code>__get_validators__()</code>  <code>classmethod</code>","text":"<p>Provide <code>BaseModel</code> with the means to convert <code>TypedObject</code>'s.</p> Source code in <code>src/notional/core.py</code> <pre><code>@classmethod\ndef __get_validators__(cls):\n    \"\"\"Provide `BaseModel` with the means to convert `TypedObject`'s.\"\"\"\n    yield cls._resolve_type\n</code></pre>"},{"location":"reference/core/#notional.core.TypedObject.__init_subclass__","title":"<code>__init_subclass__(type=None, **kwargs)</code>","text":"<p>Register the subtypes of the TypedObject subclass.</p> Source code in <code>src/notional/core.py</code> <pre><code>def __init_subclass__(cls, type=None, **kwargs):\n    \"\"\"Register the subtypes of the TypedObject subclass.\"\"\"\n    super().__init_subclass__(**kwargs)\n\n    type_name = cls.__name__ if type is None else type\n\n    cls._register_type(type_name)\n</code></pre>"},{"location":"reference/core/#notional.core.TypedObject.parse_obj","title":"<code>parse_obj(obj)</code>  <code>classmethod</code>","text":"<p>Parse the structured object data into an instance of <code>TypedObject</code>.</p> <p>This method overrides <code>BaseModel.parse_obj()</code>.</p> Source code in <code>src/notional/core.py</code> <pre><code>@classmethod\ndef parse_obj(cls, obj):\n    \"\"\"Parse the structured object data into an instance of `TypedObject`.\n\n    This method overrides `BaseModel.parse_obj()`.\n    \"\"\"\n    return cls._resolve_type(obj)\n</code></pre>"},{"location":"reference/core/#notional.core.serialize_to_api","title":"<code>serialize_to_api(data)</code>","text":"<p>Recursively convert the given data to an API-safe form.</p> <p>This is mostly to handle data types that will not directly serialize to JSON.</p> Source code in <code>src/notional/core.py</code> <pre><code>def serialize_to_api(data):\n    \"\"\"Recursively convert the given data to an API-safe form.\n\n    This is mostly to handle data types that will not directly serialize to JSON.\n    \"\"\"\n\n    # https://github.com/samuelcolvin/pydantic/issues/1409\n\n    if isinstance(data, (date, datetime)):\n        return data.isoformat()\n\n    if isinstance(data, UUID):\n        return str(data)\n\n    if isinstance(data, Enum):\n        return data.value\n\n    if isinstance(data, (list, tuple)):\n        return [serialize_to_api(value) for value in data]\n\n    if isinstance(data, dict):\n        return {name: serialize_to_api(value) for name, value in data.items()}\n\n    return data\n</code></pre>"},{"location":"reference/iterator/","title":"Iterator","text":"<p>Iterator classes for working with paginated API responses.</p>"},{"location":"reference/iterator/#notional.iterator.BlockList","title":"<code>BlockList</code>","text":"<p>               Bases: <code>ObjectList</code></p> <p>A list of Block objects returned by the Notion API.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class BlockList(ObjectList, type=\"block\"):\n    \"\"\"A list of Block objects returned by the Notion API.\"\"\"\n\n    block: Any = {}\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.DatabaseList","title":"<code>DatabaseList</code>","text":"<p>               Bases: <code>ObjectList</code></p> <p>A list of Database objects returned by the Notion API.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class DatabaseList(ObjectList, type=\"database\"):\n    \"\"\"A list of Database objects returned by the Notion API.\"\"\"\n\n    database: Any = {}\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.EndpointIterator","title":"<code>EndpointIterator</code>","text":"<p>Iterates over results from a paginated API response.</p> <p>These objects may be reused, however they are not thread safe.  For example, after creating the following iterator:</p> <pre><code>notion = notional.connect(auth=NOTION_AUTH_TOKEN)\nquery = EndpointIterator(notion.databases().query)\n</code></pre> <p>The iterator may be reused with different database ID's:</p> <pre><code>for items in query(database_id=first_db):\n    ...\n\nfor items in query(database_id=second_db):\n    ...\n</code></pre> <p>Objects returned by the iterator may also be converted to a specific type.  This is most commonly used to wrap API objects with a higher-level object (such as ORM types).</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class EndpointIterator:\n    \"\"\"Iterates over results from a paginated API response.\n\n    These objects may be reused, however they are not thread safe.  For example,\n    after creating the following iterator:\n\n        notion = notional.connect(auth=NOTION_AUTH_TOKEN)\n        query = EndpointIterator(notion.databases().query)\n\n    The iterator may be reused with different database ID's:\n\n        for items in query(database_id=first_db):\n            ...\n\n        for items in query(database_id=second_db):\n            ...\n\n    Objects returned by the iterator may also be converted to a specific type.  This\n    is most commonly used to wrap API objects with a higher-level object (such as ORM\n    types).\n    \"\"\"\n\n    def __init__(self, endpoint, datatype=None):\n        \"\"\"Initialize an object list iterator for the specified endpoint.\n\n        If a class is provided, it will be constructued for each result returned by\n        this iterator.  The constructor must accept a single argument, which is the\n        `NotionObject` contained in the `ObjectList`.\n        \"\"\"\n        self._endpoint = endpoint\n        self._datatype = datatype\n\n        self.has_more = None\n        self.page_num = -1\n        self.total_items = -1\n        self.next_cursor = None\n\n    def __call__(self, **kwargs):\n        \"\"\"Return a generator for this endpoint using the given parameters.\"\"\"\n\n        self.has_more = True\n        self.page_num = 0\n        self.total_items = 0\n\n        if \"page_size\" not in kwargs:\n            kwargs[\"page_size\"] = MAX_PAGE_SIZE\n\n        self.next_cursor = kwargs.pop(\"start_cursor\", None)\n\n        while self.has_more:\n            self.page_num += 1\n\n            page = self._endpoint(start_cursor=self.next_cursor, **kwargs)\n\n            api_list = ObjectList.parse_obj(page)\n\n            for obj in api_list.results:\n                self.total_items += 1\n\n                if self._datatype is None:\n                    yield obj\n                else:\n                    yield self._datatype(obj)\n\n            self.next_cursor = api_list.next_cursor\n            self.has_more = api_list.has_more and self.next_cursor is not None\n\n    def list(self, **kwargs):\n        \"\"\"Collect all items from the endpoint as a list.\"\"\"\n\n        items = []\n\n        for item in self(**kwargs):\n            items.append(item)\n\n        return items\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.EndpointIterator.__call__","title":"<code>__call__(**kwargs)</code>","text":"<p>Return a generator for this endpoint using the given parameters.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>def __call__(self, **kwargs):\n    \"\"\"Return a generator for this endpoint using the given parameters.\"\"\"\n\n    self.has_more = True\n    self.page_num = 0\n    self.total_items = 0\n\n    if \"page_size\" not in kwargs:\n        kwargs[\"page_size\"] = MAX_PAGE_SIZE\n\n    self.next_cursor = kwargs.pop(\"start_cursor\", None)\n\n    while self.has_more:\n        self.page_num += 1\n\n        page = self._endpoint(start_cursor=self.next_cursor, **kwargs)\n\n        api_list = ObjectList.parse_obj(page)\n\n        for obj in api_list.results:\n            self.total_items += 1\n\n            if self._datatype is None:\n                yield obj\n            else:\n                yield self._datatype(obj)\n\n        self.next_cursor = api_list.next_cursor\n        self.has_more = api_list.has_more and self.next_cursor is not None\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.EndpointIterator.__init__","title":"<code>__init__(endpoint, datatype=None)</code>","text":"<p>Initialize an object list iterator for the specified endpoint.</p> <p>If a class is provided, it will be constructued for each result returned by this iterator.  The constructor must accept a single argument, which is the <code>NotionObject</code> contained in the <code>ObjectList</code>.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>def __init__(self, endpoint, datatype=None):\n    \"\"\"Initialize an object list iterator for the specified endpoint.\n\n    If a class is provided, it will be constructued for each result returned by\n    this iterator.  The constructor must accept a single argument, which is the\n    `NotionObject` contained in the `ObjectList`.\n    \"\"\"\n    self._endpoint = endpoint\n    self._datatype = datatype\n\n    self.has_more = None\n    self.page_num = -1\n    self.total_items = -1\n    self.next_cursor = None\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.EndpointIterator.list","title":"<code>list(**kwargs)</code>","text":"<p>Collect all items from the endpoint as a list.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>def list(self, **kwargs):\n    \"\"\"Collect all items from the endpoint as a list.\"\"\"\n\n    items = []\n\n    for item in self(**kwargs):\n        items.append(item)\n\n    return items\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.ObjectList","title":"<code>ObjectList</code>","text":"<p>               Bases: <code>NotionObject</code>, <code>TypedObject</code></p> <p>A paginated list of objects returned by the Notion API.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class ObjectList(NotionObject, TypedObject, object=\"list\"):\n    \"\"\"A paginated list of objects returned by the Notion API.\"\"\"\n\n    results: List[NotionObject] = []\n    has_more: bool = False\n    next_cursor: Optional[str] = None\n\n    @validator(\"results\", pre=True, each_item=True)\n    def _convert_results_list(cls, val):\n        \"\"\"Convert the results list to specifc objects.\"\"\"\n\n        if \"object\" not in val:\n            raise ValueError(\"Unknown object in results\")\n\n        if val[\"object\"] == BlockList.type:\n            return Block.parse_obj(val)\n\n        if val[\"object\"] == PageList.type:\n            return Page.parse_obj(val)\n\n        if val[\"object\"] == DatabaseList.type:\n            return Database.parse_obj(val)\n\n        if val[\"object\"] == PropertyItemList.type:\n            return PropertyItem.parse_obj(val)\n\n        if val[\"object\"] == UserList.type:\n            return User.parse_obj(val)\n\n        return GenericObject.parse_obj(val)\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.PageList","title":"<code>PageList</code>","text":"<p>               Bases: <code>ObjectList</code></p> <p>A list of Page objects returned by the Notion API.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class PageList(ObjectList, type=\"page\"):\n    \"\"\"A list of Page objects returned by the Notion API.\"\"\"\n\n    page: Any = {}\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.PageOrDatabaseList","title":"<code>PageOrDatabaseList</code>","text":"<p>               Bases: <code>ObjectList</code></p> <p>A list of Page or Database objects returned by the Notion API.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class PageOrDatabaseList(ObjectList, type=\"page_or_database\"):\n    \"\"\"A list of Page or Database objects returned by the Notion API.\"\"\"\n\n    page_or_database: Any = {}\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.PropertyItemList","title":"<code>PropertyItemList</code>","text":"<p>               Bases: <code>ObjectList</code></p> <p>A paginated list of property items returned by the Notion API.</p> <p>Property item lists contain one or more pages of basic property items.  These types do not typically match the schema for corresponding property values.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class PropertyItemList(ObjectList, type=\"property_item\"):\n    \"\"\"A paginated list of property items returned by the Notion API.\n\n    Property item lists contain one or more pages of basic property items.  These types\n    do not typically match the schema for corresponding property values.\n    \"\"\"\n\n    class _NestedData(GenericObject):\n        id: str = None\n        type: str = None\n        next_url: Optional[str] = None\n\n    property_item: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/iterator/#notional.iterator.UserList","title":"<code>UserList</code>","text":"<p>               Bases: <code>ObjectList</code></p> <p>A list of User objects returned by the Notion API.</p> Source code in <code>src/notional/iterator.py</code> <pre><code>class UserList(ObjectList, type=\"user\"):\n    \"\"\"A list of User objects returned by the Notion API.\"\"\"\n\n    user: Any = {}\n</code></pre>"},{"location":"reference/orm/","title":"ORM","text":"<p>Utilities for working with Notion as an ORM.</p> <p>There are two primary constructs in this module that enable custom type definitions in Notional: <code>Property()</code> and <code>connected_page()</code>.</p>"},{"location":"reference/orm/#notional.orm.ConnectedPage","title":"<code>ConnectedPage</code>","text":"<p>Base class for \"live\" pages via the Notion API.</p> <p>All changes are committed in real time.</p> Source code in <code>src/notional/orm.py</code> <pre><code>class ConnectedPage:\n    \"\"\"Base class for \"live\" pages via the Notion API.\n\n    All changes are committed in real time.\n    \"\"\"\n\n    def __init__(self, page: Page):\n        \"\"\"Construct a ConnectedPage using the underlying Page object.\"\"\"\n\n        if page.id is None:\n            raise ValueError(\"Missing ID for connected page\")\n\n        self._notional__page = page\n\n    def __init_subclass__(cls, database=None, **kwargs):\n        \"\"\"Register new subclasses of a ConnectedPage.\"\"\"\n        super(cls).__init_subclass__(**kwargs)\n\n        if database is not None:\n            cls._notional__database = database\n\n        elif hasattr(cls, \"__database__\"):\n            cls._notional__database = cls.__database__\n\n    @property\n    def id(self):\n        \"\"\"Return the ID of this page (if available).\"\"\"\n        return self._notional__page.id if self._notional__page else None\n\n    @property\n    def children(self):\n        \"\"\"Return an iterator for all child blocks of this Page.\"\"\"\n\n        if self._notional__page is None:\n            return []\n\n        return self._notional__session.blocks.children.list(parent=self._notional__page)\n\n    @property\n    def cover(self):\n        \"\"\"Return the cover for the Page.\"\"\"\n        return self._notional__page.cover\n\n    @cover.setter\n    def cover(self, file):\n        \"\"\"Set the cover for the Page.\"\"\"\n        self._notional__session.pages.set(self._notional__page, cover=file)\n\n    @property\n    def icon(self):\n        \"\"\"Return the icon for the Page.\"\"\"\n        return self._notional__page.icon\n\n    @icon.setter\n    def icon(self, icon: Union[str, EmojiObject, ExternalFile]):\n        \"\"\"Set the icon for the Page.\n\n        :param icon: may be an emoji string, `EmojiObject` or `ExternalFile`\n        \"\"\"\n\n        if isinstance(icon, str):\n            if icon.startswith(\":\"):\n                icon = emojize(icon, language=\"alias\")\n            if is_emoji(icon):\n                icon = EmojiObject[icon]\n            elif icon.startswith(\"http\"):\n                icon = ExternalFile[icon]\n            else:\n                raise ValueError(f\"Cannot interpret string `{icon}` as icon\")\n\n        elif not isinstance(icon, (EmojiObject, ExternalFile)):\n            raise ValueError(\"Invalid icon specifier; unsupported type\")\n\n        self._notional__session.pages.set(self._notional__page, icon=icon)\n\n    def __iadd__(self, block):\n        \"\"\"Append the given block to this page.\n\n        This operation takes place on the Notion server, causing the page to save\n        immediately.\n        \"\"\"\n\n        self.append(block)\n\n        return self\n\n    def append(self, *blocks):\n        \"\"\"Append the given blocks as children of this ConnectedPage.\n\n        This operation takes place on the Notion server, causing the page to update\n        immediately.\n        \"\"\"\n\n        if self._notional__page is None:\n            raise ValueError(\"Cannot append blocks; missing page\")\n\n        if self._notional__session is None:\n            raise ValueError(\"Cannot append blocks; invalid session\")\n\n        logger.debug(\n            \"appending %d blocks to page :: %s\", len(blocks), self._notional__page.id\n        )\n\n        self._notional__session.blocks.children.append(self._notional__page, *blocks)\n\n    @classmethod\n    def bind(cls, to_session):\n        \"\"\"Attach this ConnectedPage to the given session.\n\n        Setting this to None will detach the page.\n        \"\"\"\n\n        cls._notional__session = to_session\n\n    @classmethod\n    def query(cls):\n        \"\"\"Return a `QueryBuilder` for the custom type.\"\"\"\n\n        if cls._notional__session is None:\n            raise ValueError(\"Unable to query; invalid session\")\n\n        if cls._notional__database is None:\n            raise ValueError(\"Unable to query; invalid database\")\n\n        return cls._notional__session.databases.query(cls)\n\n    @classmethod\n    def create(cls, **kwargs):\n        \"\"\"Create a new instance of the ConnectedPage type.\n\n        Any properties that support object composition may be defined in `kwargs`.\n\n        This operation takes place on the Notion server, creating the page immediately.\n\n        :param kwargs: the properties to initialize for this object as parameters, i.e.\n          `name=value`, where `name` is the attribute in the custom type and `value` is\n          a supported type for composing.\n        \"\"\"\n\n        if cls._notional__session is None:\n            raise ValueError(\"Cannot create Page; invalid session\")\n\n        if cls._notional__database is None:\n            raise ValueError(\"Cannot create Page; invalid database\")\n\n        logger.debug(\"creating new %s :: %s\", cls, cls._notional__database)\n        parent = DatabaseRef(database_id=cls._notional__database)\n\n        page = cls._notional__session.pages.create(parent=parent)\n        logger.debug(\"=&gt; connected page :: %s\", page.id)\n\n        connected = cls(page)\n\n        # FIXME it would be better to convert properties to a dict and pass to the API,\n        # rather than setting them individually here...\n        for name, value in kwargs.items():\n            setattr(connected, name, value)\n\n        return connected\n\n    @classmethod\n    def parse_obj(cls, obj):\n        \"\"\"Parse the given object as a ConnectedPage.\n\n        Similar to `BaseModel.parse_obj(data)`.\n        \"\"\"\n        return cls(page=Page(**obj))\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.children","title":"<code>children</code>  <code>property</code>","text":"<p>Return an iterator for all child blocks of this Page.</p>"},{"location":"reference/orm/#notional.orm.ConnectedPage.cover","title":"<code>cover</code>  <code>property</code> <code>writable</code>","text":"<p>Return the cover for the Page.</p>"},{"location":"reference/orm/#notional.orm.ConnectedPage.icon","title":"<code>icon</code>  <code>property</code> <code>writable</code>","text":"<p>Return the icon for the Page.</p>"},{"location":"reference/orm/#notional.orm.ConnectedPage.id","title":"<code>id</code>  <code>property</code>","text":"<p>Return the ID of this page (if available).</p>"},{"location":"reference/orm/#notional.orm.ConnectedPage.__iadd__","title":"<code>__iadd__(block)</code>","text":"<p>Append the given block to this page.</p> <p>This operation takes place on the Notion server, causing the page to save immediately.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def __iadd__(self, block):\n    \"\"\"Append the given block to this page.\n\n    This operation takes place on the Notion server, causing the page to save\n    immediately.\n    \"\"\"\n\n    self.append(block)\n\n    return self\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.__init__","title":"<code>__init__(page)</code>","text":"<p>Construct a ConnectedPage using the underlying Page object.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def __init__(self, page: Page):\n    \"\"\"Construct a ConnectedPage using the underlying Page object.\"\"\"\n\n    if page.id is None:\n        raise ValueError(\"Missing ID for connected page\")\n\n    self._notional__page = page\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.__init_subclass__","title":"<code>__init_subclass__(database=None, **kwargs)</code>","text":"<p>Register new subclasses of a ConnectedPage.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def __init_subclass__(cls, database=None, **kwargs):\n    \"\"\"Register new subclasses of a ConnectedPage.\"\"\"\n    super(cls).__init_subclass__(**kwargs)\n\n    if database is not None:\n        cls._notional__database = database\n\n    elif hasattr(cls, \"__database__\"):\n        cls._notional__database = cls.__database__\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.append","title":"<code>append(*blocks)</code>","text":"<p>Append the given blocks as children of this ConnectedPage.</p> <p>This operation takes place on the Notion server, causing the page to update immediately.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def append(self, *blocks):\n    \"\"\"Append the given blocks as children of this ConnectedPage.\n\n    This operation takes place on the Notion server, causing the page to update\n    immediately.\n    \"\"\"\n\n    if self._notional__page is None:\n        raise ValueError(\"Cannot append blocks; missing page\")\n\n    if self._notional__session is None:\n        raise ValueError(\"Cannot append blocks; invalid session\")\n\n    logger.debug(\n        \"appending %d blocks to page :: %s\", len(blocks), self._notional__page.id\n    )\n\n    self._notional__session.blocks.children.append(self._notional__page, *blocks)\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.bind","title":"<code>bind(to_session)</code>  <code>classmethod</code>","text":"<p>Attach this ConnectedPage to the given session.</p> <p>Setting this to None will detach the page.</p> Source code in <code>src/notional/orm.py</code> <pre><code>@classmethod\ndef bind(cls, to_session):\n    \"\"\"Attach this ConnectedPage to the given session.\n\n    Setting this to None will detach the page.\n    \"\"\"\n\n    cls._notional__session = to_session\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.create","title":"<code>create(**kwargs)</code>  <code>classmethod</code>","text":"<p>Create a new instance of the ConnectedPage type.</p> <p>Any properties that support object composition may be defined in <code>kwargs</code>.</p> <p>This operation takes place on the Notion server, creating the page immediately.</p> <p>:param kwargs: the properties to initialize for this object as parameters, i.e.   <code>name=value</code>, where <code>name</code> is the attribute in the custom type and <code>value</code> is   a supported type for composing.</p> Source code in <code>src/notional/orm.py</code> <pre><code>@classmethod\ndef create(cls, **kwargs):\n    \"\"\"Create a new instance of the ConnectedPage type.\n\n    Any properties that support object composition may be defined in `kwargs`.\n\n    This operation takes place on the Notion server, creating the page immediately.\n\n    :param kwargs: the properties to initialize for this object as parameters, i.e.\n      `name=value`, where `name` is the attribute in the custom type and `value` is\n      a supported type for composing.\n    \"\"\"\n\n    if cls._notional__session is None:\n        raise ValueError(\"Cannot create Page; invalid session\")\n\n    if cls._notional__database is None:\n        raise ValueError(\"Cannot create Page; invalid database\")\n\n    logger.debug(\"creating new %s :: %s\", cls, cls._notional__database)\n    parent = DatabaseRef(database_id=cls._notional__database)\n\n    page = cls._notional__session.pages.create(parent=parent)\n    logger.debug(\"=&gt; connected page :: %s\", page.id)\n\n    connected = cls(page)\n\n    # FIXME it would be better to convert properties to a dict and pass to the API,\n    # rather than setting them individually here...\n    for name, value in kwargs.items():\n        setattr(connected, name, value)\n\n    return connected\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.parse_obj","title":"<code>parse_obj(obj)</code>  <code>classmethod</code>","text":"<p>Parse the given object as a ConnectedPage.</p> <p>Similar to <code>BaseModel.parse_obj(data)</code>.</p> Source code in <code>src/notional/orm.py</code> <pre><code>@classmethod\ndef parse_obj(cls, obj):\n    \"\"\"Parse the given object as a ConnectedPage.\n\n    Similar to `BaseModel.parse_obj(data)`.\n    \"\"\"\n    return cls(page=Page(**obj))\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPage.query","title":"<code>query()</code>  <code>classmethod</code>","text":"<p>Return a <code>QueryBuilder</code> for the custom type.</p> Source code in <code>src/notional/orm.py</code> <pre><code>@classmethod\ndef query(cls):\n    \"\"\"Return a `QueryBuilder` for the custom type.\"\"\"\n\n    if cls._notional__session is None:\n        raise ValueError(\"Unable to query; invalid session\")\n\n    if cls._notional__database is None:\n        raise ValueError(\"Unable to query; invalid database\")\n\n    return cls._notional__session.databases.query(cls)\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPageFactory","title":"<code>ConnectedPageFactory</code>","text":"<p>A factory that builds custom types for <code>ConnectedPage</code> classes.</p> <p>Typically, these generated classes will be extended to form a custom type.</p> Source code in <code>src/notional/orm.py</code> <pre><code>class ConnectedPageFactory:\n    \"\"\"A factory that builds custom types for `ConnectedPage` classes.\n\n    Typically, these generated classes will be extended to form a custom type.\n    \"\"\"\n\n    # TODO consider making this more general purpose (e.g. extend other base objects)\n\n    def __init__(\n        self,\n        name=\"CustomBase\",\n        base=None,\n        metaclass=None,\n    ):\n        \"\"\"Initialize the `ConnectedPageFactory` with the given parameters.\n\n        :param name: the name of the class generated by this factory;\n          defaults to \"CustomBase\"\n\n        :param base: the class (or tuple of classes) used as the base class for types\n          generated by this factory; defaults to `None`\n\n        :param metaclass: the callable metaclass to use for generating new types;\n          defaults to `type`\n        \"\"\"\n\n        self.name = name\n\n        if base is None:\n            self.bases = (ConnectedPage,)\n        elif isinstance(base, tuple):\n            self.bases = base\n        else:\n            self.bases = (base,)\n\n        if metaclass is None:\n            self.metaclass = type\n        else:\n            self.metaclass = metaclass\n\n    def __call__(self, session, database, schema=None):\n        \"\"\"Return a new type from this factory with the given configuration.\"\"\"\n\n        attrs = {\n            \"_notional__session\": session,\n            \"_notional__database\": database,\n        }\n\n        if schema is not None:\n            for name, obj in schema.items():\n                safe_name = make_safe_python_name(name)\n                prop = Property(name, obj)\n                attrs[safe_name] = prop\n\n        return self.metaclass(self.name, self.bases, attrs)\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPageFactory.__call__","title":"<code>__call__(session, database, schema=None)</code>","text":"<p>Return a new type from this factory with the given configuration.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def __call__(self, session, database, schema=None):\n    \"\"\"Return a new type from this factory with the given configuration.\"\"\"\n\n    attrs = {\n        \"_notional__session\": session,\n        \"_notional__database\": database,\n    }\n\n    if schema is not None:\n        for name, obj in schema.items():\n            safe_name = make_safe_python_name(name)\n            prop = Property(name, obj)\n            attrs[safe_name] = prop\n\n    return self.metaclass(self.name, self.bases, attrs)\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedPageFactory.__init__","title":"<code>__init__(name='CustomBase', base=None, metaclass=None)</code>","text":"<p>Initialize the <code>ConnectedPageFactory</code> with the given parameters.</p> <p>:param name: the name of the class generated by this factory;   defaults to \"CustomBase\"</p> <p>:param base: the class (or tuple of classes) used as the base class for types   generated by this factory; defaults to <code>None</code></p> <p>:param metaclass: the callable metaclass to use for generating new types;   defaults to <code>type</code></p> Source code in <code>src/notional/orm.py</code> <pre><code>def __init__(\n    self,\n    name=\"CustomBase\",\n    base=None,\n    metaclass=None,\n):\n    \"\"\"Initialize the `ConnectedPageFactory` with the given parameters.\n\n    :param name: the name of the class generated by this factory;\n      defaults to \"CustomBase\"\n\n    :param base: the class (or tuple of classes) used as the base class for types\n      generated by this factory; defaults to `None`\n\n    :param metaclass: the callable metaclass to use for generating new types;\n      defaults to `type`\n    \"\"\"\n\n    self.name = name\n\n    if base is None:\n        self.bases = (ConnectedPage,)\n    elif isinstance(base, tuple):\n        self.bases = base\n    else:\n        self.bases = (base,)\n\n    if metaclass is None:\n        self.metaclass = type\n    else:\n        self.metaclass = metaclass\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedProperty","title":"<code>ConnectedProperty</code>","text":"<p>Contains the information and methods needed for a connected property.</p> <p>When created, this object does not have a reference to its parent object.  Before this property is accessed for the first time, callers must use <code>bind()</code> to set the containing object at runtime.</p> Source code in <code>src/notional/orm.py</code> <pre><code>class ConnectedProperty:\n    \"\"\"Contains the information and methods needed for a connected property.\n\n    When created, this object does not have a reference to its parent object.  Before\n    this property is accessed for the first time, callers must use `bind()` to set the\n    containing object at runtime.\n    \"\"\"\n\n    def __init__(self, name, schema, default=...):\n        \"\"\"Initialize the property wrapper.\n\n        :param name: the name of this property as it appears on Notional\n\n        :param schema: the PropertyObject that defines the type of this property\n\n        :param default: an optional parameter that will return a default value if one\n          is not provided by the API\n        \"\"\"\n\n        if name is None or len(name) == 0:\n            raise ValueError(\"Must provide a valid property name\")\n\n        if schema is None:\n            raise ValueError(\"Invalid schema; cannot be None\")\n\n        self.name = name\n        self.default = default\n        self.schema = schema\n        self.data_type = type(schema)\n\n        if not hasattr(self.data_type, \"type\") or self.data_type.type is None:\n            raise ValueError(\"Invalid schema; undefined type\")\n\n        self.type_name = self.data_type.type\n\n        # this is kind of an ugly way to grab the value type from the schema type...\n        # mostly b/c we are using internal knowledge of TypedObject.__notional_typemap__\n        if self.type_name not in PropertyValue.__notional_typemap__:\n            raise TypeError(f\"Invalid schema; missing value type - {self.type_name}\")\n\n        self.value_type = PropertyValue.__notional_typemap__[self.type_name]\n\n    def bind(self, obj):\n        \"\"\"Binds this property to the given object.\"\"\"\n\n        if not isinstance(obj, ConnectedPage):\n            raise TypeError(\"Properties must be used in a ConnectedPage object\")\n\n        # XXX should we do any additional error checking on the object?\n\n        self.parent = obj\n        self.page_data = self.parent._notional__page\n        self.session = self.parent._notional__session\n\n    def get(self):\n        \"\"\"Return the current value of the property as a python object.\"\"\"\n        logger.debug(\"fget :: %s [%s]\", self.type_name, self.name)\n\n        # TODO raise instead?\n        if self.page_data is None:\n            return None\n\n        try:\n            prop = self.page_data[self.name]\n        except AttributeError as err:\n            if self.default == ...:\n                raise err\n            return self.default\n\n        if not isinstance(prop, self.value_type):\n            raise TypeError(\"Type mismatch\")\n\n        if hasattr(prop, \"Value\"):\n            return prop.Value\n\n        return prop\n\n    def set(self, value):\n        \"\"\"Set the property to the given value.\"\"\"\n        logger.debug(\"fset :: %s [%s] =&gt; %s\", self.type_name, self.name, type(value))\n\n        # TODO raise instead?\n        if self.page_data is None:\n            return\n\n        if isinstance(value, self.value_type):\n            prop = value\n\n        elif hasattr(self.value_type, \"__compose__\"):\n            prop = self.value_type[value]\n\n        else:\n            raise TypeError(f\"Unsupported value type for {self.type_name}\")\n\n        # update the property on the server (which will refresh the local data)\n        self.session.pages.update(self.page_data, **{self.name: prop})\n\n    def delete(self):\n        \"\"\"Delete the value associated with this property.\"\"\"\n\n        # TODO raise instead?\n        if self.page_data is None:\n            return\n\n        empty = self.value_type()\n\n        self.session.pages.update(self.page_data, **{self.name: empty})\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedProperty.__init__","title":"<code>__init__(name, schema, default=...)</code>","text":"<p>Initialize the property wrapper.</p> <p>:param name: the name of this property as it appears on Notional</p> <p>:param schema: the PropertyObject that defines the type of this property</p> <p>:param default: an optional parameter that will return a default value if one   is not provided by the API</p> Source code in <code>src/notional/orm.py</code> <pre><code>def __init__(self, name, schema, default=...):\n    \"\"\"Initialize the property wrapper.\n\n    :param name: the name of this property as it appears on Notional\n\n    :param schema: the PropertyObject that defines the type of this property\n\n    :param default: an optional parameter that will return a default value if one\n      is not provided by the API\n    \"\"\"\n\n    if name is None or len(name) == 0:\n        raise ValueError(\"Must provide a valid property name\")\n\n    if schema is None:\n        raise ValueError(\"Invalid schema; cannot be None\")\n\n    self.name = name\n    self.default = default\n    self.schema = schema\n    self.data_type = type(schema)\n\n    if not hasattr(self.data_type, \"type\") or self.data_type.type is None:\n        raise ValueError(\"Invalid schema; undefined type\")\n\n    self.type_name = self.data_type.type\n\n    # this is kind of an ugly way to grab the value type from the schema type...\n    # mostly b/c we are using internal knowledge of TypedObject.__notional_typemap__\n    if self.type_name not in PropertyValue.__notional_typemap__:\n        raise TypeError(f\"Invalid schema; missing value type - {self.type_name}\")\n\n    self.value_type = PropertyValue.__notional_typemap__[self.type_name]\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedProperty.bind","title":"<code>bind(obj)</code>","text":"<p>Binds this property to the given object.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def bind(self, obj):\n    \"\"\"Binds this property to the given object.\"\"\"\n\n    if not isinstance(obj, ConnectedPage):\n        raise TypeError(\"Properties must be used in a ConnectedPage object\")\n\n    # XXX should we do any additional error checking on the object?\n\n    self.parent = obj\n    self.page_data = self.parent._notional__page\n    self.session = self.parent._notional__session\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedProperty.delete","title":"<code>delete()</code>","text":"<p>Delete the value associated with this property.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def delete(self):\n    \"\"\"Delete the value associated with this property.\"\"\"\n\n    # TODO raise instead?\n    if self.page_data is None:\n        return\n\n    empty = self.value_type()\n\n    self.session.pages.update(self.page_data, **{self.name: empty})\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedProperty.get","title":"<code>get()</code>","text":"<p>Return the current value of the property as a python object.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def get(self):\n    \"\"\"Return the current value of the property as a python object.\"\"\"\n    logger.debug(\"fget :: %s [%s]\", self.type_name, self.name)\n\n    # TODO raise instead?\n    if self.page_data is None:\n        return None\n\n    try:\n        prop = self.page_data[self.name]\n    except AttributeError as err:\n        if self.default == ...:\n            raise err\n        return self.default\n\n    if not isinstance(prop, self.value_type):\n        raise TypeError(\"Type mismatch\")\n\n    if hasattr(prop, \"Value\"):\n        return prop.Value\n\n    return prop\n</code></pre>"},{"location":"reference/orm/#notional.orm.ConnectedProperty.set","title":"<code>set(value)</code>","text":"<p>Set the property to the given value.</p> Source code in <code>src/notional/orm.py</code> <pre><code>def set(self, value):\n    \"\"\"Set the property to the given value.\"\"\"\n    logger.debug(\"fset :: %s [%s] =&gt; %s\", self.type_name, self.name, type(value))\n\n    # TODO raise instead?\n    if self.page_data is None:\n        return\n\n    if isinstance(value, self.value_type):\n        prop = value\n\n    elif hasattr(self.value_type, \"__compose__\"):\n        prop = self.value_type[value]\n\n    else:\n        raise TypeError(f\"Unsupported value type for {self.type_name}\")\n\n    # update the property on the server (which will refresh the local data)\n    self.session.pages.update(self.page_data, **{self.name: prop})\n</code></pre>"},{"location":"reference/orm/#notional.orm.Property","title":"<code>Property(name, schema=None, default=...)</code>","text":"<p>Define a property for a Notion Page object.</p> <p>Internally, this method uses a custom wrapper to manage the property methods.</p> <p>:param name: the Notion table property name :param schema: the schema that defines this property (default = RichText) :param default: a default value when creating new objects</p> Source code in <code>src/notional/orm.py</code> <pre><code>def Property(name, schema=None, default=...):\n    \"\"\"Define a property for a Notion Page object.\n\n    Internally, this method uses a custom wrapper to manage the property methods.\n\n    :param name: the Notion table property name\n    :param schema: the schema that defines this property (default = RichText)\n    :param default: a default value when creating new objects\n    \"\"\"\n\n    logger.debug(\"creating new Property: %s\", name)\n\n    if schema is None:\n        schema = RichText()\n\n    elif not isinstance(schema, PropertyObject):\n        raise TypeError(\"Invalid data_type; not a PropertyObject\")\n\n    cprop = ConnectedProperty(\n        name=name,\n        schema=schema,\n        default=default,\n    )\n\n    def fget(self):\n        \"\"\"Return the current value of the property as a python object.\"\"\"\n        cprop.bind(self)\n        return cprop.get()\n\n    def fset(self, value):\n        \"\"\"Set the property to the given value.\"\"\"\n        cprop.bind(self)\n        cprop.set(value)\n\n    def fdel(self):\n        \"\"\"Delete the value for this property.\"\"\"\n        cprop.bind(self)\n        cprop.delete()\n\n    return property(fget, fset, fdel)\n</code></pre>"},{"location":"reference/orm/#notional.orm.connected_page","title":"<code>connected_page(session=None, source_db=None, schema=None, cls=None)</code>","text":"<p>Return a base class for \"connected\" pages through the Notion API.</p> <p>Subclasses may then inherit from the returned class to define custom ORM types.</p> <p>:param session: an active Notional session where the database is hosted</p> <p>:param source_db: if provided, the returned class will use the ID and schema of   this object to initialize the connected page</p> <p>:param schema: if provided, the returned class will contain properties according   to the schema provided; defaults to <code>None</code></p> <p>:param cls: the returned class will inherit from the given class, which must be a   subclass of <code>ConnectedPage</code>; defaults to <code>ConnectedPage</code></p> Source code in <code>src/notional/orm.py</code> <pre><code>def connected_page(session=None, source_db=None, schema=None, cls=None):\n    \"\"\"Return a base class for \"connected\" pages through the Notion API.\n\n    Subclasses may then inherit from the returned class to define custom ORM types.\n\n    :param session: an active Notional session where the database is hosted\n\n    :param source_db: if provided, the returned class will use the ID and schema of\n      this object to initialize the connected page\n\n    :param schema: if provided, the returned class will contain properties according\n      to the schema provided; defaults to `None`\n\n    :param cls: the returned class will inherit from the given class, which must be a\n      subclass of `ConnectedPage`; defaults to `ConnectedPage`\n    \"\"\"\n\n    if cls is None:\n        cls = ConnectedPage\n\n    elif not issubclass(cls, ConnectedPage):\n        raise ValueError(\"'cls' must subclass ConnectedPage\")\n\n    dbid = None\n\n    if source_db is not None:\n        if schema is None:\n            schema = source_db.properties\n\n        dbid = source_db.id\n\n    factory = ConnectedPageFactory(base=cls)\n\n    return factory(\n        session=session,\n        database=dbid,\n        schema=schema,\n    )\n</code></pre>"},{"location":"reference/parser/","title":"Parser","text":"<p>Utilities for parsing other document types in Notion.</p> <p>These parsers provide an alternative to the \"Import\" capabilities of the Notion client and Notion Web Clipper.  Perhaps that capability will be exposed to the API in the future, which would effectively render these parsers unnecessary.</p>"},{"location":"reference/parser/#notional.parser.CsvParser","title":"<code>CsvParser</code>","text":"<p>               Bases: <code>DocumentParser</code></p> <p>A standard CSV parser.</p> <p>Contents of this parser are available as a list of page properties according to the determined schema.  Specifically, this content follows the format:</p> <pre><code>```\n[\n    {\n        column_1_name: entry_1_column_1_data,\n        column_2_name: entry_1_column_2_data,\n        column_3_name: entry_1_column_3_data,\n        ...\n    },\n    {\n        column_1_name: entry_2_column_1_data,\n        column_2_name: entry_2_column_2_data,\n        column_3_name: entry_2_column_3_data,\n        ...\n    },\n    ...\n]\n```\n</code></pre> Source code in <code>src/notional/parser.py</code> <pre><code>class CsvParser(DocumentParser):\n    \"\"\"A standard CSV parser.\n\n    Contents of this parser are available as a list of page properties according to the\n    determined schema.  Specifically, this content follows the format:\n\n        ```\n        [\n            {\n                column_1_name: entry_1_column_1_data,\n                column_2_name: entry_1_column_2_data,\n                column_3_name: entry_1_column_3_data,\n                ...\n            },\n            {\n                column_1_name: entry_2_column_1_data,\n                column_2_name: entry_2_column_2_data,\n                column_3_name: entry_2_column_3_data,\n                ...\n            },\n            ...\n        ]\n        ```\n    \"\"\"\n\n    schema: dict\n\n    def __init__(self, header_row=True, title_column=0):\n        \"\"\"Initialize a new `CsvParser`.\n\n        :param header_row: indicates that data will have a header row (for the schema)\n        :param title_column: set the column in data to use for page titles\n        \"\"\"\n        super().__init__()\n\n        self._has_header = header_row\n        self._title_index = title_column\n\n        self.schema = {}\n\n        self._field_names = []\n\n    def parse(self, data):\n        \"\"\"Parse the given CSV data.\n\n        Upon return, the following properties will be available in the parser:\n            `schema`: a computed schema for the supplied data\n            `title`: the name of the CSV file being parsed (if available)\n            `content`: a list of page properties with the tabular data\n        \"\"\"\n        super().parse(data)\n\n        if isinstance(data, str):\n            data = io.StringIO(data, newline=\"\")\n\n        reader = csv.reader(data)\n\n        self._process(reader)\n\n    def _process(self, reader):\n        # build the schema based on the first row\n\n        try:\n            header = next(reader)\n        except StopIteration:\n            raise ValueError(\"Invalid CSV: empty data\") from None\n\n        if self._has_header:\n            self._build_schema(*header)\n\n        else:\n            cols = [str(num) for num in range(len(header))]\n            self._build_schema(*cols)\n            self._build_record(*header)\n\n        # process remaining entries\n\n        for entry in reader:\n            self._build_record(*entry)\n\n    def _build_schema(self, *fields):\n        if fields is None or len(fields) &lt; 1:\n            raise ValueError(\"Invalid CSV: empty header\")\n\n        column = 0\n\n        for field in fields:\n            field = field.strip()\n\n            while field in self._field_names:\n                field = f\"{field}_{column}\"\n\n            if column == self._title_index:\n                self.schema[field] = schema.Title()\n            else:\n                self.schema[field] = schema.RichText()\n\n            self._field_names.append(field)\n\n            column += 1\n\n    def _build_record(self, *fields):\n        if len(fields) != len(self._field_names):\n            raise ValueError(\"Invalid CSV: incorrect number of fields in data\")\n\n        record = {}\n\n        column = 0\n\n        for col in self._field_names:\n            value = fields[column]\n\n            if column == self._title_index:\n                record[col] = types.Title[value]\n            else:\n                record[col] = types.RichText[value]\n\n            column += 1\n\n        self.content.append(record)\n</code></pre>"},{"location":"reference/parser/#notional.parser.CsvParser.__init__","title":"<code>__init__(header_row=True, title_column=0)</code>","text":"<p>Initialize a new <code>CsvParser</code>.</p> <p>:param header_row: indicates that data will have a header row (for the schema) :param title_column: set the column in data to use for page titles</p> Source code in <code>src/notional/parser.py</code> <pre><code>def __init__(self, header_row=True, title_column=0):\n    \"\"\"Initialize a new `CsvParser`.\n\n    :param header_row: indicates that data will have a header row (for the schema)\n    :param title_column: set the column in data to use for page titles\n    \"\"\"\n    super().__init__()\n\n    self._has_header = header_row\n    self._title_index = title_column\n\n    self.schema = {}\n\n    self._field_names = []\n</code></pre>"},{"location":"reference/parser/#notional.parser.CsvParser.parse","title":"<code>parse(data)</code>","text":"<p>Parse the given CSV data.</p> <p>Upon return, the following properties will be available in the parser:     <code>schema</code>: a computed schema for the supplied data     <code>title</code>: the name of the CSV file being parsed (if available)     <code>content</code>: a list of page properties with the tabular data</p> Source code in <code>src/notional/parser.py</code> <pre><code>def parse(self, data):\n    \"\"\"Parse the given CSV data.\n\n    Upon return, the following properties will be available in the parser:\n        `schema`: a computed schema for the supplied data\n        `title`: the name of the CSV file being parsed (if available)\n        `content`: a list of page properties with the tabular data\n    \"\"\"\n    super().parse(data)\n\n    if isinstance(data, str):\n        data = io.StringIO(data, newline=\"\")\n\n    reader = csv.reader(data)\n\n    self._process(reader)\n</code></pre>"},{"location":"reference/parser/#notional.parser.DocumentParser","title":"<code>DocumentParser</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for document parsers.</p> Source code in <code>src/notional/parser.py</code> <pre><code>class DocumentParser(ABC):\n    \"\"\"Base class for document parsers.\"\"\"\n\n    title: str\n    content: list\n\n    def __init__(self):\n        \"\"\"Initialize the document parser.\"\"\"\n        self.title = None\n        self.content = []\n\n    @abstractmethod\n    def parse(self, data):\n        \"\"\"Parse the given data.\n\n        This method will attempt to determine a default name for the document from the\n        data source.\n\n        Subclasses should call this method when implemting `parse()` locally.\n        \"\"\"\n\n        if hasattr(data, \"name\"):\n            self.title = basename(data.name)\n</code></pre>"},{"location":"reference/parser/#notional.parser.DocumentParser.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the document parser.</p> Source code in <code>src/notional/parser.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the document parser.\"\"\"\n    self.title = None\n    self.content = []\n</code></pre>"},{"location":"reference/parser/#notional.parser.DocumentParser.parse","title":"<code>parse(data)</code>  <code>abstractmethod</code>","text":"<p>Parse the given data.</p> <p>This method will attempt to determine a default name for the document from the data source.</p> <p>Subclasses should call this method when implemting <code>parse()</code> locally.</p> Source code in <code>src/notional/parser.py</code> <pre><code>@abstractmethod\ndef parse(self, data):\n    \"\"\"Parse the given data.\n\n    This method will attempt to determine a default name for the document from the\n    data source.\n\n    Subclasses should call this method when implemting `parse()` locally.\n    \"\"\"\n\n    if hasattr(data, \"name\"):\n        self.title = basename(data.name)\n</code></pre>"},{"location":"reference/parser/#notional.parser.HtmlParser","title":"<code>HtmlParser</code>","text":"<p>               Bases: <code>DocumentParser</code></p> <p>An HTML parser that leverages the WHATWG HTML spec.</p> Source code in <code>src/notional/parser.py</code> <pre><code>class HtmlParser(DocumentParser):\n    \"\"\"An HTML parser that leverages the WHATWG HTML spec.\"\"\"\n\n    meta: dict\n\n    def __init__(self, base=None):\n        \"\"\"Initialize an empty `HtmlParser`.\n\n        :param base: the base URL for resolving relative paths\n        \"\"\"\n        super().__init__()\n\n        self._base_url = base\n\n        self.meta = {}\n\n        self._current_href = None\n        self._current_text_style = Annotations()\n\n    def parse(self, data):\n        \"\"\"Parse the given HTML data.\n\n        Upon return, the following properties will be available in the parser:\n            `title`: contents of the `&lt;title&gt;` element if found\n            `content`: a list of blocks containing rendered content from the HTML data\n            `meta`: a dictionary of any `&lt;meta&gt;` tags that were found\n        \"\"\"\n        super().parse(data)\n\n        doc = html5lib.parse(data, namespaceHTMLElements=False)\n\n        self._render(doc)\n\n    def _render(self, elem, parent=None):\n        \"\"\"Render the given element as a child of `parent`.\n\n        This method will look for an appropriate `render_*` method to handle the given\n        tag name.  If there is not an available method, the element will be ignored.\n\n        :param elem: the ElementTree object to render\n        :param parent: the parent block for the rendered content or `None`\n        \"\"\"\n        logger.debug(\"rendering element - %s :: %s\", elem.tag, type(parent))\n\n        if parent is None:\n            parent = self.content\n\n        if hasattr(self, f\"_render_{elem.tag}\"):\n            logger.debug(\"handler func -- _render_%s\", elem.tag)\n            pfunc = getattr(self, f\"_render_{elem.tag}\")\n            pfunc(elem, parent)\n\n        logger.debug(\"block complete; %d total block(s)\", len(self.content))\n\n    def _render_a(self, elem, parent):\n        self._current_href = elem.get(\"href\")\n        self._process_contents(elem, parent=parent)\n        self._current_href = None\n\n    def _render_b(self, elem, parent):\n        self._current_text_style.bold = True\n        self._process_contents(elem, parent=parent)\n        self._current_text_style.bold = False\n\n    def _render_base(self, elem, parent):\n        base = elem.get(\"href\")\n        if base is not None:\n            self._base_url = base\n\n    def _render_blockquote(self, elem, parent):\n        block = blocks.Quote()\n        self._process_contents(elem, parent=block)\n        parent.append(block)\n\n    def _render_body(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_br(self, elem, parent):\n        if isinstance(parent, blocks.TextBlock):\n            parent.concat(\"\\n\")\n\n    def _render_code(self, elem, parent):\n        self._current_text_style.code = True\n        self._process_contents(elem, parent=parent)\n        self._current_text_style.code = False\n\n    def _render_dd(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_del(self, elem, parent):\n        self._current_text_style.strikethrough = True\n        self._process_contents(elem, parent=parent)\n        self._current_text_style.strikethrough = False\n\n    def _render_div(self, elem, parent):\n        self._process_contents(elem, parent)\n\n    def _render_dl(self, elem, parent):\n        dl = blocks.Paragraph()\n        self._process_contents(elem, parent=dl)\n        parent.append(dl)\n\n    def _render_dt(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_em(self, elem, parent):\n        self._render_i(elem, parent)\n\n    def _render_h1(self, elem, parent):\n        h1 = blocks.Heading1()\n        self._process_contents(elem, parent=h1)\n        parent.append(h1)\n\n    def _render_h2(self, elem, parent):\n        h2 = blocks.Heading2()\n        self._process_contents(elem, parent=h2)\n        parent.append(h2)\n\n    def _render_h3(self, elem, parent):\n        h3 = blocks.Heading3()\n        self._process_contents(elem, parent=h3)\n        parent.append(h3)\n\n    def _render_h4(self, elem, parent):\n        self._render_h3(elem, parent)\n\n    def _render_h5(self, elem, parent):\n        self._render_h3(elem, parent)\n\n    def _render_h6(self, elem, parent):\n        self._render_h3(elem, parent)\n\n    def _render_head(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_hgroup(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_hr(self, elem, parent):\n        parent.append(blocks.Divider())\n\n    def _render_html(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_i(self, elem, parent):\n        self._current_text_style.italic = True\n        self._process_contents(elem, parent=parent)\n        self._current_text_style.italic = False\n\n    def _render_iframe(self, elem, parent):\n        src = elem.get(\"src\")\n        if src is not None:\n            block = blocks.Embed[src]\n            parent.append(block)\n\n    def _render_img(self, elem, parent):\n        src = elem.get(\"src\")\n\n        # TODO use self._base_url for relative paths\n        # TODO support embedded images (data:image) as HostedFile...\n\n        if src is not None:\n            file = types.ExternalFile[src]\n            img = blocks.Image(image=file)\n\n            parent.append(img)\n\n    def _render_ins(self, elem, parent):\n        self._render_u(elem, parent)\n\n    def _render_kbd(self, elem, parent):\n        self._render_code(elem, parent)\n\n    def _render_li(self, elem, parent):\n        self._process_contents(elem, parent)\n\n    def _render_menu(self, elem, parent):\n        self._render_ul(elem, parent)\n\n    def _render_meta(self, elem, parent):\n        name = elem.get(\"name\")\n        value = elem.get(\"content\")\n        if name and value:\n            self.meta[name] = value\n\n    def _render_object(self, elem, parent):\n        # XXX support 'data' attribute as an embed or upload?\n        self._process_contents(elem, parent=parent)\n\n    def _render_ol(self, elem, parent):\n        self._process_list(elem, parent, blocks.NumberedListItem)\n\n    def _render_p(self, elem, parent):\n        para = blocks.Paragraph()\n        self._process_contents(elem, parent=para)\n        parent.append(para)\n\n    def _render_pre(self, elem, parent):\n        block = blocks.Code()\n        self._process_contents(elem, parent=block)\n        parent.append(block)\n\n    def _render_s(self, elem, parent):\n        self._render_del(elem, parent)\n\n    def _render_samp(self, elem, parent):\n        self._render_code(elem, parent)\n\n    def _render_span(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_strike(self, elem, parent):\n        self._render_del(elem, parent)\n\n    def _render_strong(self, elem, parent):\n        self._render_b(elem, parent)\n\n    def _render_table(self, elem, parent):\n        table = blocks.Table()\n        self._process_contents(elem, parent=table)\n\n        if table.Width &gt; 0:\n            parent.append(table)\n\n    def _render_tbody(self, elem, parent):\n        self._process_contents(elem, parent)\n\n    def _render_td(self, elem, parent):\n        if not isinstance(parent, blocks.TableRow):\n            raise TypeError(\"Invalid parent for &lt;td&gt;\")\n\n        if elem_has_text(elem):\n            self._process_contents(elem, parent=parent)\n        else:\n            self._append_text(\"\", parent)\n\n    def _render_tfoot(self, elem, parent):\n        self._process_contents(elem, parent=parent)\n\n    def _render_th(self, elem, parent):\n        self._render_td(elem, parent=parent)\n\n    def _render_thead(self, elem, parent):\n        if not isinstance(parent, blocks.Table):\n            raise TypeError(\"Invalid parent for &lt;thead&gt;\")\n\n        parent.table.has_column_header = True\n        self._process_contents(elem, parent=parent)\n\n    def _render_title(self, elem, parent):\n        self.title = gather_text(elem)\n\n    def _render_tr(self, elem, parent):\n        if not isinstance(parent, blocks.Table):\n            raise TypeError(\"Invalid parent for &lt;tr&gt;\")\n\n        row = blocks.TableRow()\n        for td in elem.findall(\"td\"):\n            self._render(td, parent=row)\n\n        parent.append(row)\n\n    def _render_tt(self, elem, parent):\n        self._render_pre(elem, parent=parent)\n\n    def _render_u(self, elem, parent):\n        self._current_text_style.underline = True\n        self._process_contents(elem, parent=parent)\n        self._current_text_style.underline = False\n\n    def _render_ul(self, elem, parent):\n        self._process_list(elem, parent, blocks.BulletedListItem)\n\n    def _render_var(self, elem, parent):\n        self._render_code(elem, parent=parent)\n\n    def _append_text(self, text, parent):\n        \"\"\"Append text to the given parent using current style and link information.\n\n        If the parent does not support text children, the text will be ignored.\n\n        When appropriate, whitespace in the text will be removed.\n        \"\"\"\n        logger.debug(\"appending text :: %s =&gt; '%s'\", parent.type, truncate(text, 10))\n\n        if not isinstance(parent, blocks.Code):\n            text = condense_text(text)\n\n        obj = TextObject[text, self._current_href, self._current_text_style]\n\n        if isinstance(parent, blocks.TextBlock):\n            if obj is not None:\n                parent.concat(obj)\n\n        elif isinstance(parent, blocks.TableRow):\n            parent.append(obj)\n\n    def _process_contents(self, elem, parent):\n        \"\"\"Process the contents of the given element as children of `parent`.\n\n        This will process all children of the element, including text and nodes.\n        \"\"\"\n        logger.debug(\"processing contents :: %s %s\", elem.tag, type(parent))\n\n        # empty elements don't need text processing...\n        if not elem_has_text(elem, with_children=False):\n            has_text = False\n\n        # TextBlock's can hold text directly...\n        elif isinstance(parent, blocks.TextBlock):\n            has_text = True\n\n        # so can TableRow's...\n        elif isinstance(parent, blocks.TableRow):\n            has_text = True\n\n        # otherwise, we need a new parent to hold text...\n        else:\n            has_text = True\n            new_parent = blocks.Paragraph()\n            parent.append(new_parent)\n            parent = new_parent\n\n        if has_text:\n            self._append_text(elem.text, parent)\n\n        for child in elem:\n            self._render(child, parent)\n\n            if has_text:\n                self._append_text(child.tail, parent)\n\n        if isinstance(parent, blocks.TextBlock):\n            strip_text_block(parent)\n\n    def _process_list(self, elem, parent, kind):\n        \"\"\"Process contents of the given element as a list.\n\n        :param elem: the element to process\n        :param parent: the parent for list items and nested lists\n        :param kind: a class used to render `&lt;li&gt;` tags\n        \"\"\"\n        list_parent = parent\n\n        for child in elem:\n            if child.tag == \"li\":\n                list_parent = kind()\n                self._render(child, parent=list_parent)\n                parent.append(list_parent)\n            else:\n                self._render(child, list_parent)\n\n    def _process_img_data(self, elem):\n        import base64\n        import tempfile\n\n        logger.debug(\"processing image\")\n\n        # TODO this probably needs more error handling and better flow\n\n        img_src = elem[\"src\"]\n        m = img_data_re.match(img_src)\n\n        if m is None:\n            raise ValueError(\"Image data missing\")\n\n        img_type = m.groups()[0]\n        img_data_enc = m.groups()[1]\n        img_data_str = m.groups()[2]\n\n        logger.debug(\"decoding embedded image: %s [%s]\", img_type, img_data_enc)\n\n        if img_data_enc == \"base64\":\n            logger.debug(\"decoding base64 image: %d bytes\", len(img_data_str))\n            img_data_b64 = img_data_str.encode(\"ascii\")\n            img_data = base64.b64decode(img_data_b64)\n        else:\n            raise ValueError(f\"Unsupported img encoding: {img_data_enc}\")\n\n        logger.debug(\"preparing %d bytes for image upload\", len(img_data))\n\n        with tempfile.NamedTemporaryFile(suffix=f\".{img_type}\") as fp:\n            logger.debug(\"using temporary file: %s\", fp.name)\n            fp.write(img_data)\n</code></pre>"},{"location":"reference/parser/#notional.parser.HtmlParser.__init__","title":"<code>__init__(base=None)</code>","text":"<p>Initialize an empty <code>HtmlParser</code>.</p> <p>:param base: the base URL for resolving relative paths</p> Source code in <code>src/notional/parser.py</code> <pre><code>def __init__(self, base=None):\n    \"\"\"Initialize an empty `HtmlParser`.\n\n    :param base: the base URL for resolving relative paths\n    \"\"\"\n    super().__init__()\n\n    self._base_url = base\n\n    self.meta = {}\n\n    self._current_href = None\n    self._current_text_style = Annotations()\n</code></pre>"},{"location":"reference/parser/#notional.parser.HtmlParser.parse","title":"<code>parse(data)</code>","text":"<p>Parse the given HTML data.</p> <p>Upon return, the following properties will be available in the parser:     <code>title</code>: contents of the <code>&lt;title&gt;</code> element if found     <code>content</code>: a list of blocks containing rendered content from the HTML data     <code>meta</code>: a dictionary of any <code>&lt;meta&gt;</code> tags that were found</p> Source code in <code>src/notional/parser.py</code> <pre><code>def parse(self, data):\n    \"\"\"Parse the given HTML data.\n\n    Upon return, the following properties will be available in the parser:\n        `title`: contents of the `&lt;title&gt;` element if found\n        `content`: a list of blocks containing rendered content from the HTML data\n        `meta`: a dictionary of any `&lt;meta&gt;` tags that were found\n    \"\"\"\n    super().parse(data)\n\n    doc = html5lib.parse(data, namespaceHTMLElements=False)\n\n    self._render(doc)\n</code></pre>"},{"location":"reference/parser/#notional.parser.condense_text","title":"<code>condense_text(text)</code>","text":"<p>Collapse contiguous whitespace from the given text.</p> Source code in <code>src/notional/parser.py</code> <pre><code>def condense_text(text):\n    \"\"\"Collapse contiguous whitespace from the given text.\"\"\"\n\n    if text is None:\n        return None\n\n    return re.sub(r\"\\s+\", \" \", text, flags=re.MULTILINE)\n</code></pre>"},{"location":"reference/parser/#notional.parser.elem_has_text","title":"<code>elem_has_text(elem, with_children=True)</code>","text":"<p>Determine if the element has any visible text.</p> <p>:param elem: the element to examine :param with_children: whether to include children nodes in the search</p> Source code in <code>src/notional/parser.py</code> <pre><code>def elem_has_text(elem, with_children=True):\n    \"\"\"Determine if the element has any visible text.\n\n    :param elem: the element to examine\n    :param with_children: whether to include children nodes in the search\n    \"\"\"\n\n    # first, check the direct text of the element...\n    if elem.text is not None and not elem.text.isspace():\n        return True\n\n    # now, we need to check the tail of each child...\n    for child in elem:\n        if with_children and elem_has_text(child):\n            return True\n\n        if child.tail is None:\n            continue\n\n        if not child.tail.isspace():\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/parser/#notional.parser.gather_text","title":"<code>gather_text(elem)</code>","text":"<p>Return all text from the element and children.</p> Source code in <code>src/notional/parser.py</code> <pre><code>def gather_text(elem):\n    \"\"\"Return all text from the element and children.\"\"\"\n    text = \"\".join(elem.itertext())\n    return normalize_text(text)\n</code></pre>"},{"location":"reference/parser/#notional.parser.normalize_text","title":"<code>normalize_text(text)</code>","text":"<p>Remove extra whitespace from the given text.</p> Source code in <code>src/notional/parser.py</code> <pre><code>def normalize_text(text):\n    \"\"\"Remove extra whitespace from the given text.\"\"\"\n\n    if text is None:\n        return None\n\n    text = text.strip()\n\n    return condense_text(text)\n</code></pre>"},{"location":"reference/parser/#notional.parser.strip_text_block","title":"<code>strip_text_block(block)</code>","text":"<p>Remove leading and trailing whitespace from text in the given block.</p> Source code in <code>src/notional/parser.py</code> <pre><code>def strip_text_block(block):\n    \"\"\"Remove leading and trailing whitespace from text in the given block.\"\"\"\n\n    if not isinstance(block, blocks.TextBlock):\n        return\n\n    if isinstance(block, blocks.Code):\n        return\n\n    block_text = block.__text__\n\n    if block_text is not None and len(block_text) &gt; 0:\n        lstrip(block_text[0])\n        rstrip(block_text[-1])\n</code></pre>"},{"location":"reference/query/","title":"Query","text":"<p>Provides an interactive query builder for Notion databases.</p>"},{"location":"reference/query/#notional.query.CheckboxCondition","title":"<code>CheckboxCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents checkbox criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class CheckboxCondition(GenericObject):\n    \"\"\"Represents checkbox criteria in Notion.\"\"\"\n\n    equals: Optional[bool] = None\n    does_not_equal: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.CompoundFilter","title":"<code>CompoundFilter</code>","text":"<p>               Bases: <code>QueryFilter</code></p> <p>Represents a compound filter in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class CompoundFilter(QueryFilter):\n    \"\"\"Represents a compound filter in Notion.\"\"\"\n\n    class Config:\n        \"\"\"Pydantic configuration class to support keyword fields.\"\"\"\n\n        allow_population_by_field_name = True\n\n    and_: Optional[List[QueryFilter]] = Field(None, alias=\"and\")\n    or_: Optional[List[QueryFilter]] = Field(None, alias=\"or\")\n</code></pre>"},{"location":"reference/query/#notional.query.CompoundFilter.Config","title":"<code>Config</code>","text":"<p>Pydantic configuration class to support keyword fields.</p> Source code in <code>src/notional/query.py</code> <pre><code>class Config:\n    \"\"\"Pydantic configuration class to support keyword fields.\"\"\"\n\n    allow_population_by_field_name = True\n</code></pre>"},{"location":"reference/query/#notional.query.CreatedTimeFilter","title":"<code>CreatedTimeFilter</code>","text":"<p>               Bases: <code>TimestampFilter</code></p> <p>Represents a created_time filter in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class CreatedTimeFilter(TimestampFilter):\n    \"\"\"Represents a created_time filter in Notion.\"\"\"\n\n    created_time: DateCondition\n    timestamp: TimestampKind = TimestampKind.CREATED_TIME\n\n    @classmethod\n    def __compose__(cls, value):\n        \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\"\n        return CreatedTimeFilter(created_time=value)\n</code></pre>"},{"location":"reference/query/#notional.query.CreatedTimeFilter.__compose__","title":"<code>__compose__(value)</code>  <code>classmethod</code>","text":"<p>Create a new <code>CreatedTimeFilter</code> using the given constraint.</p> Source code in <code>src/notional/query.py</code> <pre><code>@classmethod\ndef __compose__(cls, value):\n    \"\"\"Create a new `CreatedTimeFilter` using the given constraint.\"\"\"\n    return CreatedTimeFilter(created_time=value)\n</code></pre>"},{"location":"reference/query/#notional.query.DateCondition","title":"<code>DateCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents date criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class DateCondition(GenericObject):\n    \"\"\"Represents date criteria in Notion.\"\"\"\n\n    equals: Optional[Union[date, datetime]] = None\n    before: Optional[Union[date, datetime]] = None\n    after: Optional[Union[date, datetime]] = None\n    on_or_before: Optional[Union[date, datetime]] = None\n    on_or_after: Optional[Union[date, datetime]] = None\n\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n\n    past_week: Optional[Any] = None\n    past_month: Optional[Any] = None\n    past_year: Optional[Any] = None\n    next_week: Optional[Any] = None\n    next_month: Optional[Any] = None\n    next_year: Optional[Any] = None\n</code></pre>"},{"location":"reference/query/#notional.query.FilesCondition","title":"<code>FilesCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents files criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class FilesCondition(GenericObject):\n    \"\"\"Represents files criteria in Notion.\"\"\"\n\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.FormulaCondition","title":"<code>FormulaCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents formula criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class FormulaCondition(GenericObject):\n    \"\"\"Represents formula criteria in Notion.\"\"\"\n\n    string: Optional[TextCondition] = None\n    checkbox: Optional[CheckboxCondition] = None\n    number: Optional[NumberCondition] = None\n    date: Optional[DateCondition] = None\n</code></pre>"},{"location":"reference/query/#notional.query.LastEditedTimeFilter","title":"<code>LastEditedTimeFilter</code>","text":"<p>               Bases: <code>TimestampFilter</code></p> <p>Represents a last_edited_time filter in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class LastEditedTimeFilter(TimestampFilter):\n    \"\"\"Represents a last_edited_time filter in Notion.\"\"\"\n\n    last_edited_time: DateCondition\n    timestamp: TimestampKind = TimestampKind.LAST_EDITED_TIME\n\n    @classmethod\n    def __compose__(cls, value):\n        \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\"\n        return LastEditedTimeFilter(last_edited_time=value)\n</code></pre>"},{"location":"reference/query/#notional.query.LastEditedTimeFilter.__compose__","title":"<code>__compose__(value)</code>  <code>classmethod</code>","text":"<p>Create a new <code>LastEditedTimeFilter</code> using the given constraint.</p> Source code in <code>src/notional/query.py</code> <pre><code>@classmethod\ndef __compose__(cls, value):\n    \"\"\"Create a new `LastEditedTimeFilter` using the given constraint.\"\"\"\n    return LastEditedTimeFilter(last_edited_time=value)\n</code></pre>"},{"location":"reference/query/#notional.query.MultiSelectCondition","title":"<code>MultiSelectCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents a multi_select criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class MultiSelectCondition(GenericObject):\n    \"\"\"Represents a multi_select criteria in Notion.\"\"\"\n\n    contains: Optional[str] = None\n    does_not_contains: Optional[str] = None\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.NumberCondition","title":"<code>NumberCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents number criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class NumberCondition(GenericObject):\n    \"\"\"Represents number criteria in Notion.\"\"\"\n\n    equals: Optional[Union[float, int]] = None\n    does_not_equal: Optional[Union[float, int]] = None\n    greater_than: Optional[Union[float, int]] = None\n    less_than: Optional[Union[float, int]] = None\n    greater_than_or_equal_to: Optional[Union[float, int]] = None\n    less_than_or_equal_to: Optional[Union[float, int]] = None\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.PeopleCondition","title":"<code>PeopleCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents people criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class PeopleCondition(GenericObject):\n    \"\"\"Represents people criteria in Notion.\"\"\"\n\n    contains: Optional[UUID] = None\n    does_not_contain: Optional[UUID] = None\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.PropertyFilter","title":"<code>PropertyFilter</code>","text":"<p>               Bases: <code>QueryFilter</code></p> <p>Represents a database property filter in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class PropertyFilter(QueryFilter):\n    \"\"\"Represents a database property filter in Notion.\"\"\"\n\n    property: str\n\n    rich_text: Optional[TextCondition] = None\n    phone_number: Optional[TextCondition] = None\n    number: Optional[NumberCondition] = None\n    checkbox: Optional[CheckboxCondition] = None\n    select: Optional[SelectCondition] = None\n    multi_select: Optional[MultiSelectCondition] = None\n    date: Optional[DateCondition] = None\n    people: Optional[PeopleCondition] = None\n    files: Optional[FilesCondition] = None\n    relation: Optional[RelationCondition] = None\n    formula: Optional[FormulaCondition] = None\n</code></pre>"},{"location":"reference/query/#notional.query.PropertySort","title":"<code>PropertySort</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents a sort instruction in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class PropertySort(GenericObject):\n    \"\"\"Represents a sort instruction in Notion.\"\"\"\n\n    property: Optional[str] = None\n    timestamp: Optional[TimestampKind] = None\n    direction: Optional[SortDirection] = None\n</code></pre>"},{"location":"reference/query/#notional.query.Query","title":"<code>Query</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents a query object in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class Query(GenericObject):\n    \"\"\"Represents a query object in Notion.\"\"\"\n\n    sorts: Optional[List[PropertySort]] = None\n    filter: Optional[QueryFilter] = None\n    start_cursor: Optional[UUID] = None\n    page_size: int = MAX_PAGE_SIZE\n\n    @validator(\"page_size\")\n    def valid_page_size(cls, value):\n        \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\"\n\n        assert value &gt; 0, \"size must be greater than zero\"\n        assert value &lt;= MAX_PAGE_SIZE, \"size must be less than or equal to 100\"\n\n        return value\n</code></pre>"},{"location":"reference/query/#notional.query.Query.valid_page_size","title":"<code>valid_page_size(value)</code>","text":"<p>Validate that the given page size meets the Notion API requirements.</p> Source code in <code>src/notional/query.py</code> <pre><code>@validator(\"page_size\")\ndef valid_page_size(cls, value):\n    \"\"\"Validate that the given page size meets the Notion API requirements.\"\"\"\n\n    assert value &gt; 0, \"size must be greater than zero\"\n    assert value &lt;= MAX_PAGE_SIZE, \"size must be less than or equal to 100\"\n\n    return value\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder","title":"<code>QueryBuilder</code>","text":"<p>A query builder for the Notion API.</p> <p>:param endpoint: the session endpoint used to execute the query :param datatype: an optional class to capture results :param params: optional params that will be passed to the query</p> Source code in <code>src/notional/query.py</code> <pre><code>class QueryBuilder:\n    \"\"\"A query builder for the Notion API.\n\n    :param endpoint: the session endpoint used to execute the query\n    :param datatype: an optional class to capture results\n    :param params: optional params that will be passed to the query\n    \"\"\"\n\n    def __init__(self, endpoint, datatype=None, **params):\n        \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\"\n\n        self.endpoint = endpoint\n        self.datatype = datatype\n        self.params = params\n\n        self.query = Query()\n\n    def filter(self, filter=None, **kwargs):\n        \"\"\"Add the given filter to the query.\"\"\"\n\n        if filter is None:\n            if isinstance(self.endpoint, SearchEndpoint):\n                filter = SearchFilter.parse_obj(kwargs)\n            elif \"property\" in kwargs:\n                filter = PropertyFilter.parse_obj(kwargs)\n            elif \"timestamp\" in kwargs and kwargs[\"timestamp\"] == \"created_time\":\n                filter = CreatedTimeFilter.parse_obj(kwargs)\n            elif \"timestamp\" in kwargs and kwargs[\"timestamp\"] == \"last_edited_time\":\n                filter = LastEditedTimeFilter.parse_obj(kwargs)\n            else:\n                raise ValueError(\"unrecognized filter\")\n\n        elif not isinstance(filter, QueryFilter):\n            raise ValueError(\"filter must be of type QueryFilter\")\n\n        # use CompoundFilter when necessary...\n\n        if self.query.filter is None:\n            self.query.filter = filter\n\n        elif isinstance(self.query.filter, CompoundFilter):\n            self.query.filter.and_.append(filter)\n\n        else:\n            old_filter = self.query.filter\n            self.query.filter = CompoundFilter(and_=[old_filter, filter])\n\n        return self\n\n    def sort(self, sort=None, **kwargs):\n        \"\"\"Add the given sort elements to the query.\"\"\"\n\n        # XXX should this support ORM properties also?\n        # e.g. - query.sort(property=Task.Title)\n        # but users won't always use ORM for queries...\n\n        if sort is None:\n            sort = PropertySort(**kwargs)\n\n        elif not isinstance(filter, PropertySort):\n            raise ValueError(\"sort must be of type PropertySort\")\n\n        # use multiple sorts when necessary\n\n        if self.query.sorts is None:\n            self.query.sorts = [sort]\n\n        else:\n            self.query.sorts.append(sort)\n\n        return self\n\n    def start_at(self, page_id):\n        \"\"\"Set the start cursor to a specific page ID.\"\"\"\n\n        self.query.start_cursor = page_id\n\n        return self\n\n    def limit(self, count):\n        \"\"\"Limit the number of results to the given count.\"\"\"\n\n        self.query.page_size = count\n\n        return self\n\n    def execute(self):\n        \"\"\"Execute the current query and return an iterator for the results.\"\"\"\n\n        if self.endpoint is None:\n            raise ValueError(\"cannot execute query; no endpoint provided\")\n\n        logger.debug(\"executing query - %s\", self.query)\n\n        query = self.query.dict()\n\n        if self.params:\n            query.update(self.params)\n\n        return EndpointIterator(self.endpoint, datatype=self.datatype)(**query)\n\n    def first(self):\n        \"\"\"Execute the current query and return the first result only.\"\"\"\n\n        try:\n            return next(self.execute())\n        except StopIteration:\n            logger.debug(\"iterator returned empty result set\")\n\n        return None\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.__init__","title":"<code>__init__(endpoint, datatype=None, **params)</code>","text":"<p>Initialize a new <code>QueryBuilder</code> for the given endpoint.</p> Source code in <code>src/notional/query.py</code> <pre><code>def __init__(self, endpoint, datatype=None, **params):\n    \"\"\"Initialize a new `QueryBuilder` for the given endpoint.\"\"\"\n\n    self.endpoint = endpoint\n    self.datatype = datatype\n    self.params = params\n\n    self.query = Query()\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.execute","title":"<code>execute()</code>","text":"<p>Execute the current query and return an iterator for the results.</p> Source code in <code>src/notional/query.py</code> <pre><code>def execute(self):\n    \"\"\"Execute the current query and return an iterator for the results.\"\"\"\n\n    if self.endpoint is None:\n        raise ValueError(\"cannot execute query; no endpoint provided\")\n\n    logger.debug(\"executing query - %s\", self.query)\n\n    query = self.query.dict()\n\n    if self.params:\n        query.update(self.params)\n\n    return EndpointIterator(self.endpoint, datatype=self.datatype)(**query)\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.filter","title":"<code>filter(filter=None, **kwargs)</code>","text":"<p>Add the given filter to the query.</p> Source code in <code>src/notional/query.py</code> <pre><code>def filter(self, filter=None, **kwargs):\n    \"\"\"Add the given filter to the query.\"\"\"\n\n    if filter is None:\n        if isinstance(self.endpoint, SearchEndpoint):\n            filter = SearchFilter.parse_obj(kwargs)\n        elif \"property\" in kwargs:\n            filter = PropertyFilter.parse_obj(kwargs)\n        elif \"timestamp\" in kwargs and kwargs[\"timestamp\"] == \"created_time\":\n            filter = CreatedTimeFilter.parse_obj(kwargs)\n        elif \"timestamp\" in kwargs and kwargs[\"timestamp\"] == \"last_edited_time\":\n            filter = LastEditedTimeFilter.parse_obj(kwargs)\n        else:\n            raise ValueError(\"unrecognized filter\")\n\n    elif not isinstance(filter, QueryFilter):\n        raise ValueError(\"filter must be of type QueryFilter\")\n\n    # use CompoundFilter when necessary...\n\n    if self.query.filter is None:\n        self.query.filter = filter\n\n    elif isinstance(self.query.filter, CompoundFilter):\n        self.query.filter.and_.append(filter)\n\n    else:\n        old_filter = self.query.filter\n        self.query.filter = CompoundFilter(and_=[old_filter, filter])\n\n    return self\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.first","title":"<code>first()</code>","text":"<p>Execute the current query and return the first result only.</p> Source code in <code>src/notional/query.py</code> <pre><code>def first(self):\n    \"\"\"Execute the current query and return the first result only.\"\"\"\n\n    try:\n        return next(self.execute())\n    except StopIteration:\n        logger.debug(\"iterator returned empty result set\")\n\n    return None\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.limit","title":"<code>limit(count)</code>","text":"<p>Limit the number of results to the given count.</p> Source code in <code>src/notional/query.py</code> <pre><code>def limit(self, count):\n    \"\"\"Limit the number of results to the given count.\"\"\"\n\n    self.query.page_size = count\n\n    return self\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.sort","title":"<code>sort(sort=None, **kwargs)</code>","text":"<p>Add the given sort elements to the query.</p> Source code in <code>src/notional/query.py</code> <pre><code>def sort(self, sort=None, **kwargs):\n    \"\"\"Add the given sort elements to the query.\"\"\"\n\n    # XXX should this support ORM properties also?\n    # e.g. - query.sort(property=Task.Title)\n    # but users won't always use ORM for queries...\n\n    if sort is None:\n        sort = PropertySort(**kwargs)\n\n    elif not isinstance(filter, PropertySort):\n        raise ValueError(\"sort must be of type PropertySort\")\n\n    # use multiple sorts when necessary\n\n    if self.query.sorts is None:\n        self.query.sorts = [sort]\n\n    else:\n        self.query.sorts.append(sort)\n\n    return self\n</code></pre>"},{"location":"reference/query/#notional.query.QueryBuilder.start_at","title":"<code>start_at(page_id)</code>","text":"<p>Set the start cursor to a specific page ID.</p> Source code in <code>src/notional/query.py</code> <pre><code>def start_at(self, page_id):\n    \"\"\"Set the start cursor to a specific page ID.\"\"\"\n\n    self.query.start_cursor = page_id\n\n    return self\n</code></pre>"},{"location":"reference/query/#notional.query.QueryFilter","title":"<code>QueryFilter</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Base class for query filters.</p> Source code in <code>src/notional/query.py</code> <pre><code>class QueryFilter(GenericObject):\n    \"\"\"Base class for query filters.\"\"\"\n</code></pre>"},{"location":"reference/query/#notional.query.RelationCondition","title":"<code>RelationCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents relation criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class RelationCondition(GenericObject):\n    \"\"\"Represents relation criteria in Notion.\"\"\"\n\n    contains: Optional[UUID] = None\n    does_not_contain: Optional[UUID] = None\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.SearchFilter","title":"<code>SearchFilter</code>","text":"<p>               Bases: <code>QueryFilter</code></p> <p>Represents a search property filter in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class SearchFilter(QueryFilter):\n    \"\"\"Represents a search property filter in Notion.\"\"\"\n\n    property: str\n    value: str\n</code></pre>"},{"location":"reference/query/#notional.query.SelectCondition","title":"<code>SelectCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents select criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class SelectCondition(GenericObject):\n    \"\"\"Represents select criteria in Notion.\"\"\"\n\n    equals: Optional[str] = None\n    does_not_equal: Optional[str] = None\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.SortDirection","title":"<code>SortDirection</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Sort direction options.</p> Source code in <code>src/notional/query.py</code> <pre><code>class SortDirection(str, Enum):\n    \"\"\"Sort direction options.\"\"\"\n\n    ASCENDING = \"ascending\"\n    DESCENDING = \"descending\"\n</code></pre>"},{"location":"reference/query/#notional.query.TextCondition","title":"<code>TextCondition</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Represents text criteria in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class TextCondition(GenericObject):\n    \"\"\"Represents text criteria in Notion.\"\"\"\n\n    equals: Optional[str] = None\n    does_not_equal: Optional[str] = None\n    contains: Optional[str] = None\n    does_not_contain: Optional[str] = None\n    starts_with: Optional[str] = None\n    ends_with: Optional[str] = None\n    is_empty: Optional[bool] = None\n    is_not_empty: Optional[bool] = None\n</code></pre>"},{"location":"reference/query/#notional.query.TimestampFilter","title":"<code>TimestampFilter</code>","text":"<p>               Bases: <code>QueryFilter</code></p> <p>Represents a timestamp filter in Notion.</p> Source code in <code>src/notional/query.py</code> <pre><code>class TimestampFilter(QueryFilter):\n    \"\"\"Represents a timestamp filter in Notion.\"\"\"\n\n    timestamp: TimestampKind\n</code></pre>"},{"location":"reference/query/#notional.query.TimestampKind","title":"<code>TimestampKind</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Possible timestamp types.</p> Source code in <code>src/notional/query.py</code> <pre><code>class TimestampKind(str, Enum):\n    \"\"\"Possible timestamp types.\"\"\"\n\n    CREATED_TIME = \"created_time\"\n    LAST_EDITED_TIME = \"last_edited_time\"\n</code></pre>"},{"location":"reference/schema/","title":"Schema","text":"<p>Objects representing a database schema.</p>"},{"location":"reference/schema/#notional.schema.Checkbox","title":"<code>Checkbox</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the checkbox configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Checkbox(PropertyObject, type=\"checkbox\"):\n    \"\"\"Defines the checkbox configuration for a database property.\"\"\"\n\n    checkbox: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.CreatedBy","title":"<code>CreatedBy</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the created-by configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class CreatedBy(PropertyObject, type=\"created_by\"):\n    \"\"\"Defines the created-by configuration for a database property.\"\"\"\n\n    created_by: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.CreatedTime","title":"<code>CreatedTime</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the created-time configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class CreatedTime(PropertyObject, type=\"created_time\"):\n    \"\"\"Defines the created-time configuration for a database property.\"\"\"\n\n    created_time: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the date configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Date(PropertyObject, type=\"date\"):\n    \"\"\"Defines the date configuration for a database property.\"\"\"\n\n    date: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.DualPropertyRelation","title":"<code>DualPropertyRelation</code>","text":"<p>               Bases: <code>PropertyRelation</code></p> <p>Defines a dual-property relation configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class DualPropertyRelation(PropertyRelation, type=\"dual_property\"):\n    \"\"\"Defines a dual-property relation configuration for a database property.\"\"\"\n\n    class _NestedData(GenericObject):\n        synced_property_name: Optional[str] = None\n        synced_property_id: Optional[str] = None\n\n    dual_property: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/schema/#notional.schema.Email","title":"<code>Email</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the email configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Email(PropertyObject, type=\"email\"):\n    \"\"\"Defines the email configuration for a database property.\"\"\"\n\n    email: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.Files","title":"<code>Files</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the files configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Files(PropertyObject, type=\"files\"):\n    \"\"\"Defines the files configuration for a database property.\"\"\"\n\n    files: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.Formula","title":"<code>Formula</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the formula configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Formula(PropertyObject, type=\"formula\"):\n    \"\"\"Defines the formula configuration for a database property.\"\"\"\n\n    class _NestedData(GenericObject):\n        expression: str = None\n\n    formula: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/schema/#notional.schema.Function","title":"<code>Function</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Standard aggregation functions.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Function(str, Enum):\n    \"\"\"Standard aggregation functions.\"\"\"\n\n    COUNT = \"count\"\n    COUNT_VALUES = \"count_values\"\n    COUNT_PER_GROUP = \"count_per_group\"\n\n    EMPTY = \"empty\"\n    NOT_EMPTY = \"not_empty\"\n\n    CHECKED = \"checked\"\n    UNCHECKED = \"unchecked\"\n\n    PERCENT_EMPTY = \"percent_empty\"\n    PERCENT_NOT_EMPTY = \"percent_not_empty\"\n    PERCENT_CHECKED = \"percent_checked\"\n    PERCENT_PER_GROUP = \"percent_per_group\"\n\n    AVERAGE = \"average\"\n    MIN = \"min\"\n    MAX = \"max\"\n    MEDIAN = \"median\"\n    RANGE = \"range\"\n    SUM = \"sum\"\n\n    DATE_RANGE = \"date_range\"\n    EARLIEST_DATE = \"earliest_date\"\n    LATEST_DATE = \"latest_date\"\n\n    SHOW_ORIGINAL = \"show_original\"\n    SHOW_UNIQUE = \"show_unique\"\n    UNIQUE = \"unique\"\n</code></pre>"},{"location":"reference/schema/#notional.schema.LastEditedBy","title":"<code>LastEditedBy</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the last-edited-by configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class LastEditedBy(PropertyObject, type=\"last_edited_by\"):\n    \"\"\"Defines the last-edited-by configuration for a database property.\"\"\"\n\n    last_edited_by: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.LastEditedTime","title":"<code>LastEditedTime</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the last-edited-time configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class LastEditedTime(PropertyObject, type=\"last_edited_time\"):\n    \"\"\"Defines the last-edited-time configuration for a database property.\"\"\"\n\n    last_edited_time: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.MultiSelect","title":"<code>MultiSelect</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the multi-select configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class MultiSelect(PropertyObject, type=\"multi_select\"):\n    \"\"\"Defines the multi-select configuration for a database property.\"\"\"\n\n    class _NestedData(GenericObject):\n        options: List[SelectOption] = []\n\n    multi_select: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/schema/#notional.schema.Number","title":"<code>Number</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the number configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Number(PropertyObject, type=\"number\"):\n    \"\"\"Defines the number configuration for a database property.\"\"\"\n\n    class _NestedData(GenericObject):\n        format: NumberFormat = NumberFormat.NUMBER\n\n        # leads to better error messages, see\n        # https://github.com/pydantic/pydantic/issues/355\n        @pydantic.validator(\"format\", pre=True)\n        def validate_enum_field(cls, field: str):\n            return NumberFormat(field)\n\n    number: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, format):\n        \"\"\"Create a `Number` object with the expected format.\"\"\"\n        return cls(number=cls._NestedData(format=format))\n</code></pre>"},{"location":"reference/schema/#notional.schema.Number.__compose__","title":"<code>__compose__(format)</code>  <code>classmethod</code>","text":"<p>Create a <code>Number</code> object with the expected format.</p> Source code in <code>src/notional/schema.py</code> <pre><code>@classmethod\ndef __compose__(cls, format):\n    \"\"\"Create a `Number` object with the expected format.\"\"\"\n    return cls(number=cls._NestedData(format=format))\n</code></pre>"},{"location":"reference/schema/#notional.schema.NumberFormat","title":"<code>NumberFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available number formats in Notion.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class NumberFormat(str, Enum):\n    \"\"\"Available number formats in Notion.\"\"\"\n\n    NUMBER = \"number\"\n    NUMBER_WITH_COMMAS = \"number_with_commas\"\n    PERCENT = \"percent\"\n    DOLLAR = \"dollar\"\n    CANADIAN_DOLLAR = \"canadian_dollar\"\n    EURO = \"euro\"\n    POUND = \"pound\"\n    YEN = \"yen\"\n    RUBLE = \"ruble\"\n    RUPEE = \"rupee\"\n    WON = \"won\"\n    YUAN = \"yuan\"\n    REAL = \"real\"\n    LIRA = \"lira\"\n    RUPIAH = \"rupiah\"\n    FRANC = \"franc\"\n    HONG_KONG_DOLLAR = \"hong_kong_dollar\"\n    NEW_ZEALAND_DOLLAR = \"new_zealand_dollar\"\n    KRONA = \"krona\"\n    NORWEGIAN_KRONE = \"norwegian_krone\"\n    MEXICAN_PESO = \"mexican_peso\"\n    RAND = \"rand\"\n    NEW_TAIWAN_DOLLAR = \"new_taiwan_dollar\"\n    DANISH_KRONE = \"danish_krone\"\n    ZLOTY = \"zloty\"\n    BAHT = \"baht\"\n    FORINT = \"forint\"\n    KORUNA = \"koruna\"\n    SHEKEL = \"shekel\"\n    CHILEAN_PESO = \"chilean_peso\"\n    PHILIPPINE_PESO = \"philippine_peso\"\n    DIRHAM = \"dirham\"\n    COLOMBIAN_PESO = \"colombian_peso\"\n    RIYAL = \"riyal\"\n    RINGGIT = \"ringgit\"\n    LEU = \"leu\"\n    ARGENTINE_PESO = \"argentine_peso\"\n    URUGUAYAN_PESO = \"uruguayan_peso\"\n</code></pre>"},{"location":"reference/schema/#notional.schema.People","title":"<code>People</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the people configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class People(PropertyObject, type=\"people\"):\n    \"\"\"Defines the people configuration for a database property.\"\"\"\n\n    people: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.PhoneNumber","title":"<code>PhoneNumber</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the phone number configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class PhoneNumber(PropertyObject, type=\"phone_number\"):\n    \"\"\"Defines the phone number configuration for a database property.\"\"\"\n\n    phone_number: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.PropertyObject","title":"<code>PropertyObject</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Base class for Notion property objects.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class PropertyObject(TypedObject):\n    \"\"\"Base class for Notion property objects.\"\"\"\n\n    id: Optional[str] = None\n    name: Optional[str] = None\n</code></pre>"},{"location":"reference/schema/#notional.schema.PropertyRelation","title":"<code>PropertyRelation</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Defines common configuration for a property relation.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class PropertyRelation(TypedObject):\n    \"\"\"Defines common configuration for a property relation.\"\"\"\n\n    database_id: UUID = None\n</code></pre>"},{"location":"reference/schema/#notional.schema.Relation","title":"<code>Relation</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the relation configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Relation(PropertyObject, type=\"relation\"):\n    \"\"\"Defines the relation configuration for a database property.\"\"\"\n\n    relation: PropertyRelation = PropertyRelation()\n</code></pre>"},{"location":"reference/schema/#notional.schema.RichText","title":"<code>RichText</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the rich text configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class RichText(PropertyObject, type=\"rich_text\"):\n    \"\"\"Defines the rich text configuration for a database property.\"\"\"\n\n    rich_text: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.Rollup","title":"<code>Rollup</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the rollup configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Rollup(PropertyObject, type=\"rollup\"):\n    \"\"\"Defines the rollup configuration for a database property.\"\"\"\n\n    class _NestedData(GenericObject):\n        function: Function = Function.COUNT\n\n        relation_property_name: Optional[str] = None\n        relation_property_id: Optional[str] = None\n\n        rollup_property_name: Optional[str] = None\n        rollup_property_id: Optional[str] = None\n\n        # leads to better error messages, see\n        # https://github.com/pydantic/pydantic/issues/355\n        @pydantic.validator(\"function\", pre=True)\n        def validate_enum_field(cls, field: str):\n            return Function(field)\n\n    rollup: _NestedData = _NestedData()\n</code></pre>"},{"location":"reference/schema/#notional.schema.Select","title":"<code>Select</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the select configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Select(PropertyObject, type=\"select\"):\n    \"\"\"Defines the select configuration for a database property.\"\"\"\n\n    class _NestedData(GenericObject):\n        options: List[SelectOption] = []\n\n    select: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, options):\n        \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\"\n        return cls(select=cls._NestedData(options=options))\n</code></pre>"},{"location":"reference/schema/#notional.schema.Select.__compose__","title":"<code>__compose__(options)</code>  <code>classmethod</code>","text":"<p>Create a <code>Select</code> object from the list of <code>SelectOption</code>'s.</p> Source code in <code>src/notional/schema.py</code> <pre><code>@classmethod\ndef __compose__(cls, options):\n    \"\"\"Create a `Select` object from the list of `SelectOption`'s.\"\"\"\n    return cls(select=cls._NestedData(options=options))\n</code></pre>"},{"location":"reference/schema/#notional.schema.SelectOption","title":"<code>SelectOption</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Options for select &amp; multi-select objects.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class SelectOption(GenericObject):\n    \"\"\"Options for select &amp; multi-select objects.\"\"\"\n\n    name: str\n    id: str = None\n    color: str = Color.DEFAULT\n\n    @classmethod\n    def __compose__(cls, name, color=Color.DEFAULT):\n        \"\"\"Create a `SelectOption` object from the given name and color.\"\"\"\n        return cls(name=name, color=color)\n</code></pre>"},{"location":"reference/schema/#notional.schema.SelectOption.__compose__","title":"<code>__compose__(name, color=Color.DEFAULT)</code>  <code>classmethod</code>","text":"<p>Create a <code>SelectOption</code> object from the given name and color.</p> Source code in <code>src/notional/schema.py</code> <pre><code>@classmethod\ndef __compose__(cls, name, color=Color.DEFAULT):\n    \"\"\"Create a `SelectOption` object from the given name and color.\"\"\"\n    return cls(name=name, color=color)\n</code></pre>"},{"location":"reference/schema/#notional.schema.SinglePropertyRelation","title":"<code>SinglePropertyRelation</code>","text":"<p>               Bases: <code>PropertyRelation</code></p> <p>Defines a single-property relation configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class SinglePropertyRelation(PropertyRelation, type=\"single_property\"):\n    \"\"\"Defines a single-property relation configuration for a database property.\"\"\"\n\n    single_property: Any = {}\n\n    @classmethod\n    def __compose__(cls, dbref):\n        \"\"\"Create a `single_property` relation using the target database reference.\n\n        `dbref` must be either a string or UUID.\n        \"\"\"\n\n        return Relation(relation=SinglePropertyRelation(database_id=dbref))\n</code></pre>"},{"location":"reference/schema/#notional.schema.SinglePropertyRelation.__compose__","title":"<code>__compose__(dbref)</code>  <code>classmethod</code>","text":"<p>Create a <code>single_property</code> relation using the target database reference.</p> <p><code>dbref</code> must be either a string or UUID.</p> Source code in <code>src/notional/schema.py</code> <pre><code>@classmethod\ndef __compose__(cls, dbref):\n    \"\"\"Create a `single_property` relation using the target database reference.\n\n    `dbref` must be either a string or UUID.\n    \"\"\"\n\n    return Relation(relation=SinglePropertyRelation(database_id=dbref))\n</code></pre>"},{"location":"reference/schema/#notional.schema.Status","title":"<code>Status</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the status configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Status(PropertyObject, type=\"status\"):\n    \"\"\"Defines the status configuration for a database property.\"\"\"\n\n    status: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.Title","title":"<code>Title</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the title configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class Title(PropertyObject, type=\"title\"):\n    \"\"\"Defines the title configuration for a database property.\"\"\"\n\n    title: Any = {}\n</code></pre>"},{"location":"reference/schema/#notional.schema.URL","title":"<code>URL</code>","text":"<p>               Bases: <code>PropertyObject</code></p> <p>Defines the URL configuration for a database property.</p> Source code in <code>src/notional/schema.py</code> <pre><code>class URL(PropertyObject, type=\"url\"):\n    \"\"\"Defines the URL configuration for a database property.\"\"\"\n\n    url: Any = {}\n</code></pre>"},{"location":"reference/session/","title":"Session","text":"<p>Provides direct access to the Notion API.</p>"},{"location":"reference/session/#notional.session.BlocksEndpoint","title":"<code>BlocksEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'blocks' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class BlocksEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'blocks' endpoint.\"\"\"\n\n    class ChildrenEndpoint(Endpoint):\n        \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\"\n\n        def __call__(self):\n            \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n            return self.session.client.blocks.children\n\n        # https://developers.notion.com/reference/patch-block-children\n        def append(self, parent, *blocks: Block, after: Block = None):\n            \"\"\"Add the given blocks as children of the specified parent.\n\n            If `after` keyword is specified, they are appended after given Block.\n\n            The blocks info will be refreshed based on returned data.\n\n            `parent` may be any suitable `ObjectReference` type.\n            \"\"\"\n\n            parent_id = ObjectReference[parent].id\n\n            children = [block.dict() for block in blocks if block is not None]\n\n            logger.info(\"Appending %d blocks to %s ...\", len(children), parent_id)\n\n            if after is None:\n                data = self().append(block_id=parent_id, children=children)\n            else:\n                after_id = str(after.id) if isinstance(after, Block) else after\n                data = self().append(\n                    block_id=parent_id, children=children, after=after_id\n                )\n\n            if \"results\" in data:\n                # in case of `after`, there is second result\n                if len(blocks) == len(data[\"results\"]) or after is not None:\n                    for idx in range(len(blocks)):\n                        block = blocks[idx]\n                        result = data[\"results\"][idx]\n                        block.refresh(**result)\n\n                else:\n                    logger.warning(\"Unable to refresh results; size mismatch\")\n\n            else:\n                logger.warning(\"Unable to refresh results; not provided\")\n\n            return parent\n\n        # https://developers.notion.com/reference/get-block-children\n        def list(self, parent):\n            \"\"\"Return all Blocks contained by the specified parent.\n\n            `parent` may be any suitable `ObjectReference` type.\n            \"\"\"\n\n            parent_id = ObjectReference[parent].id\n\n            logger.info(\"Listing blocks for %s...\", parent_id)\n\n            blocks = EndpointIterator(endpoint=self().list)\n\n            return blocks(block_id=parent_id)\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\"\n        super().__init__(*args, **kwargs)\n\n        self.children = BlocksEndpoint.ChildrenEndpoint(*args, **kwargs)\n\n    def __call__(self):\n        \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n        return self.session.client.blocks\n\n    # https://developers.notion.com/reference/delete-a-block\n    def delete(self, block):\n        \"\"\"Delete (archive) the specified Block.\n\n        `block` may be any suitable `ObjectReference` type.\n        \"\"\"\n\n        block_id = ObjectReference[block].id\n        logger.info(\"Deleting block :: %s\", block_id)\n\n        data = self().delete(block_id)\n\n        return Block.parse_obj(data)\n\n    def restore(self, block):\n        \"\"\"Restore (unarchive) the specified Block.\n\n        `block` may be any suitable `ObjectReference` type.\n        \"\"\"\n\n        block_id = ObjectReference[block].id\n        logger.info(\"Restoring block :: %s\", block_id)\n\n        data = self().update(block_id, archived=False)\n\n        return Block.parse_obj(data)\n\n    # https://developers.notion.com/reference/retrieve-a-block\n    def retrieve(self, block):\n        \"\"\"Return the requested Block.\n\n        `block` may be any suitable `ObjectReference` type.\n        \"\"\"\n\n        block_id = ObjectReference[block].id\n        logger.info(\"Retrieving block :: %s\", block_id)\n\n        data = self().retrieve(block_id)\n\n        return Block.parse_obj(data)\n\n    # https://developers.notion.com/reference/update-a-block\n    def update(self, block: Block):\n        \"\"\"Update the block content on the server.\n\n        The block info will be refreshed to the latest version from the server.\n        \"\"\"\n\n        logger.info(\"Updating block :: %s\", block.id)\n\n        data = self().update(block.id.hex, **block.dict())\n\n        return block.refresh(**data)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint","title":"<code>ChildrenEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'blocks/children' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class ChildrenEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'blocks/children' endpoint.\"\"\"\n\n    def __call__(self):\n        \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n        return self.session.client.blocks.children\n\n    # https://developers.notion.com/reference/patch-block-children\n    def append(self, parent, *blocks: Block, after: Block = None):\n        \"\"\"Add the given blocks as children of the specified parent.\n\n        If `after` keyword is specified, they are appended after given Block.\n\n        The blocks info will be refreshed based on returned data.\n\n        `parent` may be any suitable `ObjectReference` type.\n        \"\"\"\n\n        parent_id = ObjectReference[parent].id\n\n        children = [block.dict() for block in blocks if block is not None]\n\n        logger.info(\"Appending %d blocks to %s ...\", len(children), parent_id)\n\n        if after is None:\n            data = self().append(block_id=parent_id, children=children)\n        else:\n            after_id = str(after.id) if isinstance(after, Block) else after\n            data = self().append(\n                block_id=parent_id, children=children, after=after_id\n            )\n\n        if \"results\" in data:\n            # in case of `after`, there is second result\n            if len(blocks) == len(data[\"results\"]) or after is not None:\n                for idx in range(len(blocks)):\n                    block = blocks[idx]\n                    result = data[\"results\"][idx]\n                    block.refresh(**result)\n\n            else:\n                logger.warning(\"Unable to refresh results; size mismatch\")\n\n        else:\n            logger.warning(\"Unable to refresh results; not provided\")\n\n        return parent\n\n    # https://developers.notion.com/reference/get-block-children\n    def list(self, parent):\n        \"\"\"Return all Blocks contained by the specified parent.\n\n        `parent` may be any suitable `ObjectReference` type.\n        \"\"\"\n\n        parent_id = ObjectReference[parent].id\n\n        logger.info(\"Listing blocks for %s...\", parent_id)\n\n        blocks = EndpointIterator(endpoint=self().list)\n\n        return blocks(block_id=parent_id)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint.__call__","title":"<code>__call__()</code>","text":"<p>Return the underlying endpoint in the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self):\n    \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n    return self.session.client.blocks.children\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint.append","title":"<code>append(parent, *blocks, after=None)</code>","text":"<p>Add the given blocks as children of the specified parent.</p> <p>If <code>after</code> keyword is specified, they are appended after given Block.</p> <p>The blocks info will be refreshed based on returned data.</p> <p><code>parent</code> may be any suitable <code>ObjectReference</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def append(self, parent, *blocks: Block, after: Block = None):\n    \"\"\"Add the given blocks as children of the specified parent.\n\n    If `after` keyword is specified, they are appended after given Block.\n\n    The blocks info will be refreshed based on returned data.\n\n    `parent` may be any suitable `ObjectReference` type.\n    \"\"\"\n\n    parent_id = ObjectReference[parent].id\n\n    children = [block.dict() for block in blocks if block is not None]\n\n    logger.info(\"Appending %d blocks to %s ...\", len(children), parent_id)\n\n    if after is None:\n        data = self().append(block_id=parent_id, children=children)\n    else:\n        after_id = str(after.id) if isinstance(after, Block) else after\n        data = self().append(\n            block_id=parent_id, children=children, after=after_id\n        )\n\n    if \"results\" in data:\n        # in case of `after`, there is second result\n        if len(blocks) == len(data[\"results\"]) or after is not None:\n            for idx in range(len(blocks)):\n                block = blocks[idx]\n                result = data[\"results\"][idx]\n                block.refresh(**result)\n\n        else:\n            logger.warning(\"Unable to refresh results; size mismatch\")\n\n    else:\n        logger.warning(\"Unable to refresh results; not provided\")\n\n    return parent\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.ChildrenEndpoint.list","title":"<code>list(parent)</code>","text":"<p>Return all Blocks contained by the specified parent.</p> <p><code>parent</code> may be any suitable <code>ObjectReference</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def list(self, parent):\n    \"\"\"Return all Blocks contained by the specified parent.\n\n    `parent` may be any suitable `ObjectReference` type.\n    \"\"\"\n\n    parent_id = ObjectReference[parent].id\n\n    logger.info(\"Listing blocks for %s...\", parent_id)\n\n    blocks = EndpointIterator(endpoint=self().list)\n\n    return blocks(block_id=parent_id)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.__call__","title":"<code>__call__()</code>","text":"<p>Return the underlying endpoint in the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self):\n    \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n    return self.session.client.blocks\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the <code>blocks</code> endpoint for the Notion API.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize the `blocks` endpoint for the Notion API.\"\"\"\n    super().__init__(*args, **kwargs)\n\n    self.children = BlocksEndpoint.ChildrenEndpoint(*args, **kwargs)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.delete","title":"<code>delete(block)</code>","text":"<p>Delete (archive) the specified Block.</p> <p><code>block</code> may be any suitable <code>ObjectReference</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def delete(self, block):\n    \"\"\"Delete (archive) the specified Block.\n\n    `block` may be any suitable `ObjectReference` type.\n    \"\"\"\n\n    block_id = ObjectReference[block].id\n    logger.info(\"Deleting block :: %s\", block_id)\n\n    data = self().delete(block_id)\n\n    return Block.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.restore","title":"<code>restore(block)</code>","text":"<p>Restore (unarchive) the specified Block.</p> <p><code>block</code> may be any suitable <code>ObjectReference</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def restore(self, block):\n    \"\"\"Restore (unarchive) the specified Block.\n\n    `block` may be any suitable `ObjectReference` type.\n    \"\"\"\n\n    block_id = ObjectReference[block].id\n    logger.info(\"Restoring block :: %s\", block_id)\n\n    data = self().update(block_id, archived=False)\n\n    return Block.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.retrieve","title":"<code>retrieve(block)</code>","text":"<p>Return the requested Block.</p> <p><code>block</code> may be any suitable <code>ObjectReference</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def retrieve(self, block):\n    \"\"\"Return the requested Block.\n\n    `block` may be any suitable `ObjectReference` type.\n    \"\"\"\n\n    block_id = ObjectReference[block].id\n    logger.info(\"Retrieving block :: %s\", block_id)\n\n    data = self().retrieve(block_id)\n\n    return Block.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.BlocksEndpoint.update","title":"<code>update(block)</code>","text":"<p>Update the block content on the server.</p> <p>The block info will be refreshed to the latest version from the server.</p> Source code in <code>src/notional/session.py</code> <pre><code>def update(self, block: Block):\n    \"\"\"Update the block content on the server.\n\n    The block info will be refreshed to the latest version from the server.\n    \"\"\"\n\n    logger.info(\"Updating block :: %s\", block.id)\n\n    data = self().update(block.id.hex, **block.dict())\n\n    return block.refresh(**data)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint","title":"<code>DatabasesEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'databases' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class DatabasesEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'databases' endpoint.\"\"\"\n\n    def __call__(self):\n        \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n        return self.session.client.databases\n\n    def _build_request(\n        self,\n        parent: ParentRef = None,\n        schema: Dict[str, PropertyObject] = None,\n        title=None,\n    ):\n        \"\"\"Build a request payload from the given items.\n\n        *NOTE* this method does not anticipate what the request will be used for and as\n        such does not validate the inputs for any particular requests.\n        \"\"\"\n        request = {}\n\n        if parent is not None:\n            request[\"parent\"] = parent.dict()\n\n        if title is not None:\n            prop = TextObject[title]\n            request[\"title\"] = [prop.dict()]\n\n        if schema is not None:\n            request[\"properties\"] = {\n                name: value.dict() if value is not None else None\n                for name, value in schema.items()\n            }\n\n        return request\n\n    # https://developers.notion.com/reference/create-a-database\n    def create(self, parent, schema: Dict[str, PropertyObject], title=None):\n        \"\"\"Add a database to the given Page parent.\n\n        `parent` may be any suitable `PageRef` type.\n        \"\"\"\n\n        parent_ref = PageRef[parent]\n\n        logger.info(\"Creating database @ %s - %s\", parent_ref.page_id, title)\n\n        request = self._build_request(parent_ref, schema, title)\n\n        data = self().create(**request)\n\n        return Database.parse_obj(data)\n\n    # https://developers.notion.com/reference/retrieve-a-database\n    def retrieve(self, dbref):\n        \"\"\"Return the Database with the given ID.\n\n        `dbref` may be any suitable `DatabaseRef` type.\n        \"\"\"\n\n        dbid = DatabaseRef[dbref].database_id\n\n        logger.info(\"Retrieving database :: %s\", dbid)\n\n        data = self().retrieve(dbid)\n\n        return Database.parse_obj(data)\n\n    # https://developers.notion.com/reference/update-a-database\n    def update(self, dbref, title=None, schema: Dict[str, PropertyObject] = None):\n        \"\"\"Update the Database object on the server.\n\n        The database info will be refreshed to the latest version from the server.\n\n        `dbref` may be any suitable `DatabaseRef` type.\n        \"\"\"\n\n        dbid = DatabaseRef[dbref].database_id\n\n        logger.info(\"Updating database info :: %s\", dbid)\n\n        request = self._build_request(schema=schema, title=title)\n\n        if request:\n            data = self().update(dbid, **request)\n            dbref = dbref.refresh(**data)\n\n        return dbref\n\n    def delete(self, dbref):\n        \"\"\"Delete (archive) the specified Database.\n\n        `dbref` may be any suitable `DatabaseRef` type.\n        \"\"\"\n\n        dbid = DatabaseRef[dbref].database_id\n\n        logger.info(\"Deleting database :: %s\", dbid)\n\n        return self.session.blocks.delete(dbid)\n\n    def restore(self, dbref):\n        \"\"\"Restore (unarchive) the specified Database.\n\n        `dbref` may be any suitable `DatabaseRef` type.\n        \"\"\"\n\n        dbid = DatabaseRef[dbref].database_id\n\n        logger.info(\"Restoring database :: %s\", dbid)\n\n        return self.session.blocks.restore(dbid)\n\n    # https://developers.notion.com/reference/post-database-query\n    def query(self, target):\n        \"\"\"Initialize a new Query object with the target data class.\n\n        :param target: either a `DatabaseRef` type or an ORM class\n        \"\"\"\n\n        if isclass(target) and issubclass(target, ConnectedPage):\n            cls = target\n            dbid = target._notional__database\n\n            if cls._notional__session != self.session:\n                raise ValueError(\"ConnectedPage belongs to a different session\")\n\n        else:\n            cls = None\n            dbid = DatabaseRef[target].database_id\n\n        logger.info(\"Initializing database query :: {%s} [%s]\", dbid, cls)\n\n        return QueryBuilder(endpoint=self().query, datatype=cls, database_id=dbid)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.__call__","title":"<code>__call__()</code>","text":"<p>Return the underlying endpoint in the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self):\n    \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n    return self.session.client.databases\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.create","title":"<code>create(parent, schema, title=None)</code>","text":"<p>Add a database to the given Page parent.</p> <p><code>parent</code> may be any suitable <code>PageRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def create(self, parent, schema: Dict[str, PropertyObject], title=None):\n    \"\"\"Add a database to the given Page parent.\n\n    `parent` may be any suitable `PageRef` type.\n    \"\"\"\n\n    parent_ref = PageRef[parent]\n\n    logger.info(\"Creating database @ %s - %s\", parent_ref.page_id, title)\n\n    request = self._build_request(parent_ref, schema, title)\n\n    data = self().create(**request)\n\n    return Database.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.delete","title":"<code>delete(dbref)</code>","text":"<p>Delete (archive) the specified Database.</p> <p><code>dbref</code> may be any suitable <code>DatabaseRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def delete(self, dbref):\n    \"\"\"Delete (archive) the specified Database.\n\n    `dbref` may be any suitable `DatabaseRef` type.\n    \"\"\"\n\n    dbid = DatabaseRef[dbref].database_id\n\n    logger.info(\"Deleting database :: %s\", dbid)\n\n    return self.session.blocks.delete(dbid)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.query","title":"<code>query(target)</code>","text":"<p>Initialize a new Query object with the target data class.</p> <p>:param target: either a <code>DatabaseRef</code> type or an ORM class</p> Source code in <code>src/notional/session.py</code> <pre><code>def query(self, target):\n    \"\"\"Initialize a new Query object with the target data class.\n\n    :param target: either a `DatabaseRef` type or an ORM class\n    \"\"\"\n\n    if isclass(target) and issubclass(target, ConnectedPage):\n        cls = target\n        dbid = target._notional__database\n\n        if cls._notional__session != self.session:\n            raise ValueError(\"ConnectedPage belongs to a different session\")\n\n    else:\n        cls = None\n        dbid = DatabaseRef[target].database_id\n\n    logger.info(\"Initializing database query :: {%s} [%s]\", dbid, cls)\n\n    return QueryBuilder(endpoint=self().query, datatype=cls, database_id=dbid)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.restore","title":"<code>restore(dbref)</code>","text":"<p>Restore (unarchive) the specified Database.</p> <p><code>dbref</code> may be any suitable <code>DatabaseRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def restore(self, dbref):\n    \"\"\"Restore (unarchive) the specified Database.\n\n    `dbref` may be any suitable `DatabaseRef` type.\n    \"\"\"\n\n    dbid = DatabaseRef[dbref].database_id\n\n    logger.info(\"Restoring database :: %s\", dbid)\n\n    return self.session.blocks.restore(dbid)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.retrieve","title":"<code>retrieve(dbref)</code>","text":"<p>Return the Database with the given ID.</p> <p><code>dbref</code> may be any suitable <code>DatabaseRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def retrieve(self, dbref):\n    \"\"\"Return the Database with the given ID.\n\n    `dbref` may be any suitable `DatabaseRef` type.\n    \"\"\"\n\n    dbid = DatabaseRef[dbref].database_id\n\n    logger.info(\"Retrieving database :: %s\", dbid)\n\n    data = self().retrieve(dbid)\n\n    return Database.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.DatabasesEndpoint.update","title":"<code>update(dbref, title=None, schema=None)</code>","text":"<p>Update the Database object on the server.</p> <p>The database info will be refreshed to the latest version from the server.</p> <p><code>dbref</code> may be any suitable <code>DatabaseRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def update(self, dbref, title=None, schema: Dict[str, PropertyObject] = None):\n    \"\"\"Update the Database object on the server.\n\n    The database info will be refreshed to the latest version from the server.\n\n    `dbref` may be any suitable `DatabaseRef` type.\n    \"\"\"\n\n    dbid = DatabaseRef[dbref].database_id\n\n    logger.info(\"Updating database info :: %s\", dbid)\n\n    request = self._build_request(schema=schema, title=title)\n\n    if request:\n        data = self().update(dbid, **request)\n        dbref = dbref.refresh(**data)\n\n    return dbref\n</code></pre>"},{"location":"reference/session/#notional.session.Endpoint","title":"<code>Endpoint</code>","text":"<p>Notional wrapper for the API endpoints.</p> Source code in <code>src/notional/session.py</code> <pre><code>class Endpoint:\n    \"\"\"Notional wrapper for the API endpoints.\"\"\"\n\n    def __init__(self, session: Session):\n        \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\"\n        self.session = session\n</code></pre>"},{"location":"reference/session/#notional.session.Endpoint.__init__","title":"<code>__init__(session)</code>","text":"<p>Initialize the <code>Endpoint</code> for the supplied session.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __init__(self, session: Session):\n    \"\"\"Initialize the `Endpoint` for the supplied session.\"\"\"\n    self.session = session\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint","title":"<code>PagesEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'pages' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class PagesEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'pages' endpoint.\"\"\"\n\n    class PropertiesEndpoint(Endpoint):\n        \"\"\"Notional interface to the API 'pages/properties' endpoint.\"\"\"\n\n        def __call__(self):\n            \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n            return self.session.client.pages.properties\n\n        # https://developers.notion.com/reference/retrieve-a-page-property\n        def retrieve(self, page_id, property_id):\n            \"\"\"Return the Property on a specific Page with the given ID.\"\"\"\n\n            logger.info(\"Retrieving property :: %s [%s]\", property_id, page_id)\n\n            data = self().retrieve(page_id, property_id)\n\n            # TODO should PropertyListItem return an iterator instead?\n            return parse_obj_as(Union[PropertyItem, PropertyItemList], obj=data)\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize the `pages` endpoint for the Notion API.\"\"\"\n        super().__init__(*args, **kwargs)\n\n        self.properties = PagesEndpoint.PropertiesEndpoint(*args, **kwargs)\n\n    def __call__(self):\n        \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n        return self.session.client.pages\n\n    # https://developers.notion.com/reference/post-page\n    def create(self, parent, title=None, properties=None, children=None):\n        \"\"\"Add a page to the given parent (Page or Database).\n\n        `parent` may be a `ParentRef`, `Page`, or `Database` object.\n        \"\"\"\n\n        if parent is None:\n            raise ValueError(\"'parent' must be provided\")\n\n        if isinstance(parent, Page):\n            parent = PageRef[parent]\n        elif isinstance(parent, Database):\n            parent = DatabaseRef[parent]\n        elif not isinstance(parent, ParentRef):\n            raise ValueError(\"Unsupported 'parent'\")\n\n        request = {\"parent\": parent.dict()}\n\n        # the API requires a properties object, even if empty\n        if properties is None:\n            properties = {}\n\n        if title is not None:\n            properties[\"title\"] = Title[title]\n\n        request[\"properties\"] = {\n            name: prop.dict() if prop is not None else None\n            for name, prop in properties.items()\n        }\n\n        if children is not None:\n            request[\"children\"] = [\n                child.dict() for child in children if child is not None\n            ]\n\n        logger.info(\"Creating page :: %s =&gt; %s\", parent, title)\n\n        data = self().create(**request)\n\n        return Page.parse_obj(data)\n\n    def delete(self, page):\n        \"\"\"Delete (archive) the specified Page.\n\n        `page` may be any suitable `PageRef` type.\n        \"\"\"\n\n        return self.set(page, archived=True)\n\n    def restore(self, page):\n        \"\"\"Restore (unarchive) the specified Page.\n\n        `page` may be any suitable `PageRef` type.\n        \"\"\"\n\n        return self.set(page, archived=False)\n\n    # https://developers.notion.com/reference/retrieve-a-page\n    def retrieve(self, page):\n        \"\"\"Return the requested Page.\n\n        `page` may be any suitable `PageRef` type.\n        \"\"\"\n\n        page_id = PageRef[page].page_id\n\n        logger.info(\"Retrieving page :: %s\", page_id)\n\n        data = self().retrieve(page_id)\n\n        # XXX would it make sense to (optionally) expand the full properties here?\n        # e.g. call the PropertiesEndpoint to make sure all data is retrieved\n\n        return Page.parse_obj(data)\n\n    # https://developers.notion.com/reference/patch-page\n    def update(self, page: Page, **properties):\n        \"\"\"Update the Page object properties on the server.\n\n        An optional `properties` may be specified as `\"name\"`: `PropertyValue` pairs.\n\n        If `properties` are provided, only those values will be updated.\n        If `properties` is empty, all page properties will be updated.\n\n        The page info will be refreshed to the latest version from the server.\n        \"\"\"\n\n        logger.info(\"Updating page info :: %s\", page.id)\n\n        if not properties:\n            properties = page.properties\n\n        props = {\n            name: value.dict() if value is not None else None\n            for name, value in properties.items()\n        }\n\n        data = self().update(page.id.hex, properties=props)\n\n        return page.refresh(**data)\n\n    def set(self, page, cover=False, icon=False, archived=None):\n        \"\"\"Set specific page attributes (such as cover, icon, etc.) on the server.\n\n        `page` may be any suitable `PageRef` type.\n\n        To remove an attribute, set its value to None.\n        \"\"\"\n\n        page_id = PageRef[page].page_id\n\n        props = {}\n\n        if cover is None:\n            logger.info(\"Removing page cover :: %s\", page_id)\n            props[\"cover\"] = {}\n        elif cover is not False:\n            logger.info(\"Setting page cover :: %s =&gt; %s\", page_id, cover)\n            props[\"cover\"] = cover.dict()\n\n        if icon is None:\n            logger.info(\"Removing page icon :: %s\", page_id)\n            props[\"icon\"] = {}\n        elif icon is not False:\n            logger.info(\"Setting page icon :: %s =&gt; %s\", page_id, icon)\n            props[\"icon\"] = icon.dict()\n\n        if archived is False:\n            logger.info(\"Restoring page :: %s\", page_id)\n            props[\"archived\"] = False\n        elif archived is True:\n            logger.info(\"Archiving page :: %s\", page_id)\n            props[\"archived\"] = True\n\n        data = self().update(page_id.hex, **props)\n\n        return page.refresh(**data)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.PropertiesEndpoint","title":"<code>PropertiesEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'pages/properties' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class PropertiesEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'pages/properties' endpoint.\"\"\"\n\n    def __call__(self):\n        \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n        return self.session.client.pages.properties\n\n    # https://developers.notion.com/reference/retrieve-a-page-property\n    def retrieve(self, page_id, property_id):\n        \"\"\"Return the Property on a specific Page with the given ID.\"\"\"\n\n        logger.info(\"Retrieving property :: %s [%s]\", property_id, page_id)\n\n        data = self().retrieve(page_id, property_id)\n\n        # TODO should PropertyListItem return an iterator instead?\n        return parse_obj_as(Union[PropertyItem, PropertyItemList], obj=data)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.PropertiesEndpoint.__call__","title":"<code>__call__()</code>","text":"<p>Return the underlying endpoint in the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self):\n    \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n    return self.session.client.pages.properties\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.PropertiesEndpoint.retrieve","title":"<code>retrieve(page_id, property_id)</code>","text":"<p>Return the Property on a specific Page with the given ID.</p> Source code in <code>src/notional/session.py</code> <pre><code>def retrieve(self, page_id, property_id):\n    \"\"\"Return the Property on a specific Page with the given ID.\"\"\"\n\n    logger.info(\"Retrieving property :: %s [%s]\", property_id, page_id)\n\n    data = self().retrieve(page_id, property_id)\n\n    # TODO should PropertyListItem return an iterator instead?\n    return parse_obj_as(Union[PropertyItem, PropertyItemList], obj=data)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.__call__","title":"<code>__call__()</code>","text":"<p>Return the underlying endpoint in the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self):\n    \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n    return self.session.client.pages\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the <code>pages</code> endpoint for the Notion API.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize the `pages` endpoint for the Notion API.\"\"\"\n    super().__init__(*args, **kwargs)\n\n    self.properties = PagesEndpoint.PropertiesEndpoint(*args, **kwargs)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.create","title":"<code>create(parent, title=None, properties=None, children=None)</code>","text":"<p>Add a page to the given parent (Page or Database).</p> <p><code>parent</code> may be a <code>ParentRef</code>, <code>Page</code>, or <code>Database</code> object.</p> Source code in <code>src/notional/session.py</code> <pre><code>def create(self, parent, title=None, properties=None, children=None):\n    \"\"\"Add a page to the given parent (Page or Database).\n\n    `parent` may be a `ParentRef`, `Page`, or `Database` object.\n    \"\"\"\n\n    if parent is None:\n        raise ValueError(\"'parent' must be provided\")\n\n    if isinstance(parent, Page):\n        parent = PageRef[parent]\n    elif isinstance(parent, Database):\n        parent = DatabaseRef[parent]\n    elif not isinstance(parent, ParentRef):\n        raise ValueError(\"Unsupported 'parent'\")\n\n    request = {\"parent\": parent.dict()}\n\n    # the API requires a properties object, even if empty\n    if properties is None:\n        properties = {}\n\n    if title is not None:\n        properties[\"title\"] = Title[title]\n\n    request[\"properties\"] = {\n        name: prop.dict() if prop is not None else None\n        for name, prop in properties.items()\n    }\n\n    if children is not None:\n        request[\"children\"] = [\n            child.dict() for child in children if child is not None\n        ]\n\n    logger.info(\"Creating page :: %s =&gt; %s\", parent, title)\n\n    data = self().create(**request)\n\n    return Page.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.delete","title":"<code>delete(page)</code>","text":"<p>Delete (archive) the specified Page.</p> <p><code>page</code> may be any suitable <code>PageRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def delete(self, page):\n    \"\"\"Delete (archive) the specified Page.\n\n    `page` may be any suitable `PageRef` type.\n    \"\"\"\n\n    return self.set(page, archived=True)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.restore","title":"<code>restore(page)</code>","text":"<p>Restore (unarchive) the specified Page.</p> <p><code>page</code> may be any suitable <code>PageRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def restore(self, page):\n    \"\"\"Restore (unarchive) the specified Page.\n\n    `page` may be any suitable `PageRef` type.\n    \"\"\"\n\n    return self.set(page, archived=False)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.retrieve","title":"<code>retrieve(page)</code>","text":"<p>Return the requested Page.</p> <p><code>page</code> may be any suitable <code>PageRef</code> type.</p> Source code in <code>src/notional/session.py</code> <pre><code>def retrieve(self, page):\n    \"\"\"Return the requested Page.\n\n    `page` may be any suitable `PageRef` type.\n    \"\"\"\n\n    page_id = PageRef[page].page_id\n\n    logger.info(\"Retrieving page :: %s\", page_id)\n\n    data = self().retrieve(page_id)\n\n    # XXX would it make sense to (optionally) expand the full properties here?\n    # e.g. call the PropertiesEndpoint to make sure all data is retrieved\n\n    return Page.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.set","title":"<code>set(page, cover=False, icon=False, archived=None)</code>","text":"<p>Set specific page attributes (such as cover, icon, etc.) on the server.</p> <p><code>page</code> may be any suitable <code>PageRef</code> type.</p> <p>To remove an attribute, set its value to None.</p> Source code in <code>src/notional/session.py</code> <pre><code>def set(self, page, cover=False, icon=False, archived=None):\n    \"\"\"Set specific page attributes (such as cover, icon, etc.) on the server.\n\n    `page` may be any suitable `PageRef` type.\n\n    To remove an attribute, set its value to None.\n    \"\"\"\n\n    page_id = PageRef[page].page_id\n\n    props = {}\n\n    if cover is None:\n        logger.info(\"Removing page cover :: %s\", page_id)\n        props[\"cover\"] = {}\n    elif cover is not False:\n        logger.info(\"Setting page cover :: %s =&gt; %s\", page_id, cover)\n        props[\"cover\"] = cover.dict()\n\n    if icon is None:\n        logger.info(\"Removing page icon :: %s\", page_id)\n        props[\"icon\"] = {}\n    elif icon is not False:\n        logger.info(\"Setting page icon :: %s =&gt; %s\", page_id, icon)\n        props[\"icon\"] = icon.dict()\n\n    if archived is False:\n        logger.info(\"Restoring page :: %s\", page_id)\n        props[\"archived\"] = False\n    elif archived is True:\n        logger.info(\"Archiving page :: %s\", page_id)\n        props[\"archived\"] = True\n\n    data = self().update(page_id.hex, **props)\n\n    return page.refresh(**data)\n</code></pre>"},{"location":"reference/session/#notional.session.PagesEndpoint.update","title":"<code>update(page, **properties)</code>","text":"<p>Update the Page object properties on the server.</p> <p>An optional <code>properties</code> may be specified as <code>\"name\"</code>: <code>PropertyValue</code> pairs.</p> <p>If <code>properties</code> are provided, only those values will be updated. If <code>properties</code> is empty, all page properties will be updated.</p> <p>The page info will be refreshed to the latest version from the server.</p> Source code in <code>src/notional/session.py</code> <pre><code>def update(self, page: Page, **properties):\n    \"\"\"Update the Page object properties on the server.\n\n    An optional `properties` may be specified as `\"name\"`: `PropertyValue` pairs.\n\n    If `properties` are provided, only those values will be updated.\n    If `properties` is empty, all page properties will be updated.\n\n    The page info will be refreshed to the latest version from the server.\n    \"\"\"\n\n    logger.info(\"Updating page info :: %s\", page.id)\n\n    if not properties:\n        properties = page.properties\n\n    props = {\n        name: value.dict() if value is not None else None\n        for name, value in properties.items()\n    }\n\n    data = self().update(page.id.hex, properties=props)\n\n    return page.refresh(**data)\n</code></pre>"},{"location":"reference/session/#notional.session.SearchEndpoint","title":"<code>SearchEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'search' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class SearchEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'search' endpoint.\"\"\"\n\n    # https://developers.notion.com/reference/post-search\n    def __call__(self, text=None):\n        \"\"\"Perform a search with the optional text.\n\n        If specified, the call will perform a search with the given text.\n\n        :return: a `QueryBuilder` with the requested search\n        :rtype: query.QueryBuilder\n        \"\"\"\n\n        params = {}\n\n        if text is not None:\n            params[\"query\"] = text\n\n        return QueryBuilder(endpoint=self.session.client.search, **params)\n</code></pre>"},{"location":"reference/session/#notional.session.SearchEndpoint.__call__","title":"<code>__call__(text=None)</code>","text":"<p>Perform a search with the optional text.</p> <p>If specified, the call will perform a search with the given text.</p> <p>:return: a <code>QueryBuilder</code> with the requested search :rtype: query.QueryBuilder</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self, text=None):\n    \"\"\"Perform a search with the optional text.\n\n    If specified, the call will perform a search with the given text.\n\n    :return: a `QueryBuilder` with the requested search\n    :rtype: query.QueryBuilder\n    \"\"\"\n\n    params = {}\n\n    if text is not None:\n        params[\"query\"] = text\n\n    return QueryBuilder(endpoint=self.session.client.search, **params)\n</code></pre>"},{"location":"reference/session/#notional.session.Session","title":"<code>Session</code>","text":"<p>An active session with the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>class Session:\n    \"\"\"An active session with the Notion SDK.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the `Session` object and the endpoints.\n\n        `kwargs` will be passed direction to the Notion SDK Client.  For more details,\n        see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/].\n\n        :param auth: bearer token for authentication\n        \"\"\"\n        self.client = notion_client.Client(**kwargs)\n\n        self.blocks = BlocksEndpoint(self)\n        self.databases = DatabasesEndpoint(self)\n        self.pages = PagesEndpoint(self)\n        self.search = SearchEndpoint(self)\n        self.users = UsersEndpoint(self)\n\n        logger.info(\"Initialized Notion SDK client\")\n\n    @property\n    def IsActive(self):\n        \"\"\"Determine if the current session is active.\n\n        The session is considered \"active\" if it has not been closed.  This does not\n        determine if the session can connect to the Notion API.\n        \"\"\"\n        return self.client is not None\n\n    def close(self):\n        \"\"\"Close the session and release resources.\"\"\"\n\n        if self.client is None:\n            raise SessionError(\"Session is not active.\")\n\n        self.client.close()\n        self.client = None\n\n    def ping(self):\n        \"\"\"Confirm that the session is active and able to connect to Notion.\n\n        Raises SessionError if there is a problem, otherwise returns True.\n        \"\"\"\n\n        if self.IsActive is False:\n            return False\n\n        error = None\n\n        try:\n            me = self.users.me()\n\n            if me is None:\n                raise SessionError(\"Unable to get current user\")\n\n        except ConnectError:\n            error = \"Unable to connect to Notion\"\n\n        except APIResponseError as err:\n            error = str(err)\n\n        if error is not None:\n            raise SessionError(error)\n\n        return True\n</code></pre>"},{"location":"reference/session/#notional.session.Session.IsActive","title":"<code>IsActive</code>  <code>property</code>","text":"<p>Determine if the current session is active.</p> <p>The session is considered \"active\" if it has not been closed.  This does not determine if the session can connect to the Notion API.</p>"},{"location":"reference/session/#notional.session.Session.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize the <code>Session</code> object and the endpoints.</p> <p><code>kwargs</code> will be passed direction to the Notion SDK Client.  For more details, see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/].</p> <p>:param auth: bearer token for authentication</p> Source code in <code>src/notional/session.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the `Session` object and the endpoints.\n\n    `kwargs` will be passed direction to the Notion SDK Client.  For more details,\n    see the (full docs)[https://ramnes.github.io/notion-sdk-py/reference/client/].\n\n    :param auth: bearer token for authentication\n    \"\"\"\n    self.client = notion_client.Client(**kwargs)\n\n    self.blocks = BlocksEndpoint(self)\n    self.databases = DatabasesEndpoint(self)\n    self.pages = PagesEndpoint(self)\n    self.search = SearchEndpoint(self)\n    self.users = UsersEndpoint(self)\n\n    logger.info(\"Initialized Notion SDK client\")\n</code></pre>"},{"location":"reference/session/#notional.session.Session.close","title":"<code>close()</code>","text":"<p>Close the session and release resources.</p> Source code in <code>src/notional/session.py</code> <pre><code>def close(self):\n    \"\"\"Close the session and release resources.\"\"\"\n\n    if self.client is None:\n        raise SessionError(\"Session is not active.\")\n\n    self.client.close()\n    self.client = None\n</code></pre>"},{"location":"reference/session/#notional.session.Session.ping","title":"<code>ping()</code>","text":"<p>Confirm that the session is active and able to connect to Notion.</p> <p>Raises SessionError if there is a problem, otherwise returns True.</p> Source code in <code>src/notional/session.py</code> <pre><code>def ping(self):\n    \"\"\"Confirm that the session is active and able to connect to Notion.\n\n    Raises SessionError if there is a problem, otherwise returns True.\n    \"\"\"\n\n    if self.IsActive is False:\n        return False\n\n    error = None\n\n    try:\n        me = self.users.me()\n\n        if me is None:\n            raise SessionError(\"Unable to get current user\")\n\n    except ConnectError:\n        error = \"Unable to connect to Notion\"\n\n    except APIResponseError as err:\n        error = str(err)\n\n    if error is not None:\n        raise SessionError(error)\n\n    return True\n</code></pre>"},{"location":"reference/session/#notional.session.SessionError","title":"<code>SessionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when there are issues with the Notion session.</p> Source code in <code>src/notional/session.py</code> <pre><code>class SessionError(Exception):\n    \"\"\"Raised when there are issues with the Notion session.\"\"\"\n\n    def __init__(self, message):\n        \"\"\"Initialize the `SessionError` with a supplied message..\"\"\"\n        super().__init__(message)\n</code></pre>"},{"location":"reference/session/#notional.session.SessionError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initialize the <code>SessionError</code> with a supplied message..</p> Source code in <code>src/notional/session.py</code> <pre><code>def __init__(self, message):\n    \"\"\"Initialize the `SessionError` with a supplied message..\"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/session/#notional.session.UsersEndpoint","title":"<code>UsersEndpoint</code>","text":"<p>               Bases: <code>Endpoint</code></p> <p>Notional interface to the API 'users' endpoint.</p> Source code in <code>src/notional/session.py</code> <pre><code>class UsersEndpoint(Endpoint):\n    \"\"\"Notional interface to the API 'users' endpoint.\"\"\"\n\n    def __call__(self):\n        \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n        return self.session.client.users\n\n    # https://developers.notion.com/reference/get-users\n    def list(self):\n        \"\"\"Return an iterator for all users in the workspace.\"\"\"\n\n        logger.info(\"Listing known users...\")\n\n        users = EndpointIterator(endpoint=self().list)\n\n        return users()\n\n    # https://developers.notion.com/reference/get-user\n    def retrieve(self, user_id):\n        \"\"\"Return the User with the given ID.\"\"\"\n\n        logger.info(\"Retrieving user :: %s\", user_id)\n\n        data = self().retrieve(user_id)\n\n        return User.parse_obj(data)\n\n    # https://developers.notion.com/reference/get-self\n    def me(self):\n        \"\"\"Return the current bot User.\"\"\"\n\n        logger.info(\"Retrieving current integration bot\")\n\n        data = self().me()\n\n        return User.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.UsersEndpoint.__call__","title":"<code>__call__()</code>","text":"<p>Return the underlying endpoint in the Notion SDK.</p> Source code in <code>src/notional/session.py</code> <pre><code>def __call__(self):\n    \"\"\"Return the underlying endpoint in the Notion SDK.\"\"\"\n    return self.session.client.users\n</code></pre>"},{"location":"reference/session/#notional.session.UsersEndpoint.list","title":"<code>list()</code>","text":"<p>Return an iterator for all users in the workspace.</p> Source code in <code>src/notional/session.py</code> <pre><code>def list(self):\n    \"\"\"Return an iterator for all users in the workspace.\"\"\"\n\n    logger.info(\"Listing known users...\")\n\n    users = EndpointIterator(endpoint=self().list)\n\n    return users()\n</code></pre>"},{"location":"reference/session/#notional.session.UsersEndpoint.me","title":"<code>me()</code>","text":"<p>Return the current bot User.</p> Source code in <code>src/notional/session.py</code> <pre><code>def me(self):\n    \"\"\"Return the current bot User.\"\"\"\n\n    logger.info(\"Retrieving current integration bot\")\n\n    data = self().me()\n\n    return User.parse_obj(data)\n</code></pre>"},{"location":"reference/session/#notional.session.UsersEndpoint.retrieve","title":"<code>retrieve(user_id)</code>","text":"<p>Return the User with the given ID.</p> Source code in <code>src/notional/session.py</code> <pre><code>def retrieve(self, user_id):\n    \"\"\"Return the User with the given ID.\"\"\"\n\n    logger.info(\"Retrieving user :: %s\", user_id)\n\n    data = self().retrieve(user_id)\n\n    return User.parse_obj(data)\n</code></pre>"},{"location":"reference/text/","title":"Text","text":"<p>Utilities for working text, markdown &amp; Rich Text in Notion.</p>"},{"location":"reference/text/#notional.text.Annotations","title":"<code>Annotations</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Style information for RichTextObject's.</p> Source code in <code>src/notional/text.py</code> <pre><code>class Annotations(GenericObject):\n    \"\"\"Style information for RichTextObject's.\"\"\"\n\n    bold: bool = False\n    italic: bool = False\n    strikethrough: bool = False\n    underline: bool = False\n    code: bool = False\n    color: FullColor = None\n\n    @property\n    def is_plain(self):\n        \"\"\"Determine if any flags are set in this `Annotations` object.\n\n        If all flags match their defaults, this is considered a \"plain\" style.\n        \"\"\"\n\n        # XXX a better approach here would be to just compare all fields to defaults\n\n        if self.bold:\n            return False\n        if self.italic:\n            return False\n        if self.strikethrough:\n            return False\n        if self.underline:\n            return False\n        if self.code:\n            return False\n        if self.color is not None:\n            return False\n        return True\n</code></pre>"},{"location":"reference/text/#notional.text.Annotations.is_plain","title":"<code>is_plain</code>  <code>property</code>","text":"<p>Determine if any flags are set in this <code>Annotations</code> object.</p> <p>If all flags match their defaults, this is considered a \"plain\" style.</p>"},{"location":"reference/text/#notional.text.CodingLanguage","title":"<code>CodingLanguage</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available coding languages.</p> Source code in <code>src/notional/text.py</code> <pre><code>class CodingLanguage(str, Enum):\n    \"\"\"Available coding languages.\"\"\"\n\n    ABAP = \"abap\"\n    ARDUINO = \"arduino\"\n    BASH = \"bash\"\n    BASIC = \"basic\"\n    C = \"c\"\n    CLOJURE = \"clojure\"\n    COFFEESCRIPT = \"coffeescript\"\n    CPP = \"c++\"\n    CSHARP = \"c#\"\n    CSS = \"css\"\n    DART = \"dart\"\n    DIFF = \"diff\"\n    DOCKER = \"docker\"\n    ELIXIR = \"elixir\"\n    ELM = \"elm\"\n    ERLANG = \"erlang\"\n    FLOW = \"flow\"\n    FORTRAN = \"fortran\"\n    FSHARP = \"f#\"\n    GHERKIN = \"gherkin\"\n    GLSL = \"glsl\"\n    GO = \"go\"\n    GRAPHQL = \"graphql\"\n    GROOVY = \"groovy\"\n    HASKELL = \"haskell\"\n    HTML = \"html\"\n    JAVA = \"java\"\n    JAVASCRIPT = \"javascript\"\n    JSON = \"json\"\n    JULIA = \"julia\"\n    KOTLIN = \"kotlin\"\n    LATEX = \"latex\"\n    LESS = \"less\"\n    LISP = \"lisp\"\n    LIVESCRIPT = \"livescript\"\n    LUA = \"lua\"\n    MAKEFILE = \"makefile\"\n    MARKDOWN = \"markdown\"\n    MARKUP = \"markup\"\n    MATLAB = \"matlab\"\n    MERMAID = \"mermaid\"\n    NIX = \"nix\"\n    OBJECTIVE_C = \"objective-c\"\n    OCAML = \"ocaml\"\n    PASCAL = \"pascal\"\n    PERL = \"perl\"\n    PHP = \"php\"\n    PLAIN_TEXT = \"plain text\"\n    POWERSHELL = \"powershell\"\n    PROLOG = \"prolog\"\n    PROTOBUF = \"protobuf\"\n    PYTHON = \"python\"\n    R = \"r\"\n    REASON = \"reason\"\n    RUBY = \"ruby\"\n    RUST = \"rust\"\n    SASS = \"sass\"\n    SCALA = \"scala\"\n    SCHEME = \"scheme\"\n    SCSS = \"scss\"\n    SHELL = \"shell\"\n    SQL = \"sql\"\n    SWIFT = \"swift\"\n    TOML = \"toml\"\n    TYPESCRIPT = \"typescript\"\n    VB_NET = \"vb.net\"\n    VERILOG = \"verilog\"\n    VHDL = \"vhdl\"\n    VISUAL_BASIC = \"visual basic\"\n    WEBASSEMBLY = \"webassembly\"\n    XML = \"xml\"\n    YAML = \"yaml\"\n    MISC = \"java/c/c++/c#\"\n</code></pre>"},{"location":"reference/text/#notional.text.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Basic color values.</p> Source code in <code>src/notional/text.py</code> <pre><code>class Color(str, Enum):\n    \"\"\"Basic color values.\"\"\"\n\n    DEFAULT = \"default\"\n    GRAY = \"gray\"\n    BROWN = \"brown\"\n    ORANGE = \"orange\"\n    YELLOW = \"yellow\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n    PURPLE = \"purple\"\n    PINK = \"pink\"\n    RED = \"red\"\n</code></pre>"},{"location":"reference/text/#notional.text.FullColor","title":"<code>FullColor</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Extended color values, including backgrounds.</p> Source code in <code>src/notional/text.py</code> <pre><code>class FullColor(str, Enum):\n    \"\"\"Extended color values, including backgrounds.\"\"\"\n\n    DEFAULT = \"default\"\n    GRAY = \"gray\"\n    BROWN = \"brown\"\n    ORANGE = \"orange\"\n    YELLOW = \"yellow\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n    PURPLE = \"purple\"\n    PINK = \"pink\"\n    RED = \"red\"\n\n    GRAY_BACKGROUND = \"gray_background\"\n    BROWN_BACKGROUND = \"brown_background\"\n    ORANGE_BACKGROUND = \"orange_background\"\n    YELLOW_BACKGROUND = \"yellow_background\"\n    GREEN_BACKGROUND = \"green_background\"\n    BLUE_BACKGROUND = \"blue_background\"\n    PURPLE_BACKGROUND = \"purple_background\"\n    PINK_BACKGROUND = \"pink_background\"\n    RED_BACKGROUND = \"red_background\"\n</code></pre>"},{"location":"reference/text/#notional.text.LinkObject","title":"<code>LinkObject</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Reference a URL.</p> Source code in <code>src/notional/text.py</code> <pre><code>class LinkObject(GenericObject):\n    \"\"\"Reference a URL.\"\"\"\n\n    type: str = \"url\"\n    url: str = None\n</code></pre>"},{"location":"reference/text/#notional.text.RichTextObject","title":"<code>RichTextObject</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Base class for Notion rich text elements.</p> Source code in <code>src/notional/text.py</code> <pre><code>class RichTextObject(TypedObject):\n    \"\"\"Base class for Notion rich text elements.\"\"\"\n\n    plain_text: str\n    href: Optional[str] = None\n    annotations: Optional[Annotations] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this object.\"\"\"\n\n        if self.href is None:\n            text = self.plain_text or \"\"\n        elif self.plain_text is None or len(self.plain_text) == 0:\n            text = f\"({self.href})\"\n        else:\n            text = f\"[{self.plain_text}]({self.href})\"\n\n        if self.annotations:\n            if self.annotations.bold:\n                text = f\"**{text}**\"\n            if self.annotations.italic:\n                text = f\"*{text}*\"\n            if self.annotations.underline:\n                text = f\"&lt;u&gt;{text}&lt;/u&gt;\"\n            if self.annotations.strikethrough:\n                text = f\"~{text}~\"\n            if self.annotations.code:\n                text = f\"`{text}`\"\n\n        return text\n\n    @classmethod\n    def __compose__(cls, text, href=None, style=None):\n        \"\"\"Compose a TextObject from the given properties.\n\n        :param text: the plain text of this object\n        :param href: an optional link for this object\n        :param style: an optional Annotations object for this text\n        \"\"\"\n\n        if text is None:\n            return None\n\n        # TODO convert markdown in text:str to RichText?\n\n        style = deepcopy(style)\n\n        return cls(plain_text=text, href=href, annotations=style)\n</code></pre>"},{"location":"reference/text/#notional.text.RichTextObject.__compose__","title":"<code>__compose__(text, href=None, style=None)</code>  <code>classmethod</code>","text":"<p>Compose a TextObject from the given properties.</p> <p>:param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text</p> Source code in <code>src/notional/text.py</code> <pre><code>@classmethod\ndef __compose__(cls, text, href=None, style=None):\n    \"\"\"Compose a TextObject from the given properties.\n\n    :param text: the plain text of this object\n    :param href: an optional link for this object\n    :param style: an optional Annotations object for this text\n    \"\"\"\n\n    if text is None:\n        return None\n\n    # TODO convert markdown in text:str to RichText?\n\n    style = deepcopy(style)\n\n    return cls(plain_text=text, href=href, annotations=style)\n</code></pre>"},{"location":"reference/text/#notional.text.RichTextObject.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this object.</p> Source code in <code>src/notional/text.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this object.\"\"\"\n\n    if self.href is None:\n        text = self.plain_text or \"\"\n    elif self.plain_text is None or len(self.plain_text) == 0:\n        text = f\"({self.href})\"\n    else:\n        text = f\"[{self.plain_text}]({self.href})\"\n\n    if self.annotations:\n        if self.annotations.bold:\n            text = f\"**{text}**\"\n        if self.annotations.italic:\n            text = f\"*{text}*\"\n        if self.annotations.underline:\n            text = f\"&lt;u&gt;{text}&lt;/u&gt;\"\n        if self.annotations.strikethrough:\n            text = f\"~{text}~\"\n        if self.annotations.code:\n            text = f\"`{text}`\"\n\n    return text\n</code></pre>"},{"location":"reference/text/#notional.text.TextObject","title":"<code>TextObject</code>","text":"<p>               Bases: <code>RichTextObject</code></p> <p>Notion text element.</p> Source code in <code>src/notional/text.py</code> <pre><code>class TextObject(RichTextObject, type=\"text\"):\n    \"\"\"Notion text element.\"\"\"\n\n    class _NestedData(GenericObject):\n        content: str = None\n        link: Optional[LinkObject] = None\n\n    text: _NestedData = _NestedData()\n\n    @classmethod\n    def __compose__(cls, text, href=None, style=None):\n        \"\"\"Compose a TextObject from the given properties.\n\n        :param text: the plain text of this object\n        :param href: an optional link for this object\n        :param style: an optional Annotations object for this text\n        \"\"\"\n\n        if text is None:\n            return None\n\n        # TODO convert markdown in text:str to RichText?\n\n        link = LinkObject(url=href) if href else None\n        nested = TextObject._NestedData(content=text, link=link)\n        style = deepcopy(style)\n\n        return cls(\n            plain_text=text,\n            text=nested,\n            href=href,\n            annotations=style,\n        )\n</code></pre>"},{"location":"reference/text/#notional.text.TextObject.__compose__","title":"<code>__compose__(text, href=None, style=None)</code>  <code>classmethod</code>","text":"<p>Compose a TextObject from the given properties.</p> <p>:param text: the plain text of this object :param href: an optional link for this object :param style: an optional Annotations object for this text</p> Source code in <code>src/notional/text.py</code> <pre><code>@classmethod\ndef __compose__(cls, text, href=None, style=None):\n    \"\"\"Compose a TextObject from the given properties.\n\n    :param text: the plain text of this object\n    :param href: an optional link for this object\n    :param style: an optional Annotations object for this text\n    \"\"\"\n\n    if text is None:\n        return None\n\n    # TODO convert markdown in text:str to RichText?\n\n    link = LinkObject(url=href) if href else None\n    nested = TextObject._NestedData(content=text, link=link)\n    style = deepcopy(style)\n\n    return cls(\n        plain_text=text,\n        text=nested,\n        href=href,\n        annotations=style,\n    )\n</code></pre>"},{"location":"reference/text/#notional.text.chunky","title":"<code>chunky(text, length=MAX_TEXT_OBJECT_SIZE)</code>","text":"<p>Break the given <code>text</code> into chunks of at most <code>length</code> size.</p> Source code in <code>src/notional/text.py</code> <pre><code>def chunky(text, length=MAX_TEXT_OBJECT_SIZE):\n    \"\"\"Break the given `text` into chunks of at most `length` size.\"\"\"\n    return (text[idx : idx + length] for idx in range(0, len(text), length))\n</code></pre>"},{"location":"reference/text/#notional.text.lstrip","title":"<code>lstrip(*rtf)</code>","text":"<p>Remove leading whitespace from each <code>TextObject</code> in the list.</p> Source code in <code>src/notional/text.py</code> <pre><code>def lstrip(*rtf):\n    \"\"\"Remove leading whitespace from each `TextObject` in the list.\"\"\"\n\n    if rtf is None or len(rtf) &lt; 1:\n        return\n\n    for obj in rtf:\n        if not isinstance(obj, TextObject):\n            raise AttributeError(\"invalid object in rtf\")\n\n        if obj.text and obj.text.content:\n            strip_text = obj.text.content.lstrip()\n            obj.text.content = strip_text\n            obj.plain_text = strip_text\n</code></pre>"},{"location":"reference/text/#notional.text.make_safe_python_name","title":"<code>make_safe_python_name(name)</code>","text":"<p>Make the given string safe for use as a Python identifier.</p> <p>This will remove any leading characters that are not valid and change all invalid interior sequences to underscore.</p> Source code in <code>src/notional/text.py</code> <pre><code>def make_safe_python_name(name):\n    \"\"\"Make the given string safe for use as a Python identifier.\n\n    This will remove any leading characters that are not valid and change all\n    invalid interior sequences to underscore.\n    \"\"\"\n\n    s = re.sub(r\"[^0-9a-zA-Z_]+\", \"_\", name)\n    s = re.sub(r\"^[^a-zA-Z]+\", \"\", s)\n\n    # remove trailing underscores\n    return s.rstrip(\"_\")\n</code></pre>"},{"location":"reference/text/#notional.text.markdown","title":"<code>markdown(*rtf)</code>","text":"<p>Return text as markdown from the list of RichText objects.</p> Source code in <code>src/notional/text.py</code> <pre><code>def markdown(*rtf):\n    \"\"\"Return text as markdown from the list of RichText objects.\"\"\"\n    return \"\".join(str(text) for text in rtf if text)\n</code></pre>"},{"location":"reference/text/#notional.text.plain_text","title":"<code>plain_text(*rtf)</code>","text":"<p>Return the combined plain text from the list of RichText objects.</p> Source code in <code>src/notional/text.py</code> <pre><code>def plain_text(*rtf):\n    \"\"\"Return the combined plain text from the list of RichText objects.\"\"\"\n    return \"\".join(text.plain_text for text in rtf if text)\n</code></pre>"},{"location":"reference/text/#notional.text.rich_text","title":"<code>rich_text(*text)</code>","text":"<p>Return a list of RichTextObject's from the list of text elements.</p> Source code in <code>src/notional/text.py</code> <pre><code>def rich_text(*text):\n    \"\"\"Return a list of RichTextObject's from the list of text elements.\"\"\"\n\n    rtf = []\n\n    for obj in text:\n        if obj is None:\n            continue\n\n        if isinstance(obj, RichTextObject):\n            rtf.append(obj)\n\n        elif isinstance(obj, str):\n            txt = text_blocks(obj)\n            rtf.extend(txt)\n\n        else:\n            raise ValueError(\"unsupported text object\")\n\n    return rtf\n</code></pre>"},{"location":"reference/text/#notional.text.rstrip","title":"<code>rstrip(*rtf)</code>","text":"<p>Remove trailing whitespace from each <code>TextObject</code> in the list.</p> Source code in <code>src/notional/text.py</code> <pre><code>def rstrip(*rtf):\n    \"\"\"Remove trailing whitespace from each `TextObject` in the list.\"\"\"\n\n    if rtf is None or len(rtf) &lt; 1:\n        return\n\n    for obj in rtf:\n        if not isinstance(obj, TextObject):\n            raise AttributeError(\"invalid object in rtf\")\n\n        if obj.text and obj.text.content:\n            strip_text = obj.text.content.rstrip()\n            obj.text.content = strip_text\n            obj.plain_text = strip_text\n</code></pre>"},{"location":"reference/text/#notional.text.strip","title":"<code>strip(*rtf)</code>","text":"<p>Remove leading and trailing whitespace from each <code>TextObject</code> in the list.</p> This is functionally equivalent to <pre><code>lstrip(*rtf)\nrstrip(*rtf)\n</code></pre> <p>:param rtf: a list of <code>TextObject</code>'s</p> Source code in <code>src/notional/text.py</code> <pre><code>def strip(*rtf):\n    \"\"\"Remove leading and trailing whitespace from each `TextObject` in the list.\n\n    This is functionally equivalent to:\n        ```python\n        lstrip(*rtf)\n        rstrip(*rtf)\n        ```\n\n    :param rtf: a list of `TextObject`'s\n    \"\"\"\n    lstrip(*rtf)\n    rstrip(*rtf)\n</code></pre>"},{"location":"reference/text/#notional.text.text_blocks","title":"<code>text_blocks(text)</code>","text":"<p>Convert the given plain text into an array of TextObject's.</p> <p>If the test is larger than the maximum block size for the Notion API, it will be broken into multiple blocks.</p> Source code in <code>src/notional/text.py</code> <pre><code>def text_blocks(text: str):\n    \"\"\"Convert the given plain text into an array of TextObject's.\n\n    If the test is larger than the maximum block size for the Notion API, it will be\n    broken into multiple blocks.\n    \"\"\"\n    return [TextObject[chunk] for chunk in chunky(text)]\n</code></pre>"},{"location":"reference/text/#notional.text.truncate","title":"<code>truncate(text, length=-1, trail='...')</code>","text":"<p>Truncate the given text, using a supplied tail as a placeholder.</p> Source code in <code>src/notional/text.py</code> <pre><code>def truncate(text, length=-1, trail=\"...\"):\n    \"\"\"Truncate the given text, using a supplied tail as a placeholder.\"\"\"\n\n    if text is None:\n        return None\n\n    # repr() includes open and close quotes...\n    literal = repr(text)[1:-1]\n\n    if 0 &lt; length &lt; len(literal):\n        literal = literal[:length]\n\n        if trail is not None:\n            literal += trail\n\n    return literal\n</code></pre>"},{"location":"reference/types/","title":"Types","text":"<p>Wrapper for Notion API data types.</p> <p>Similar to other records, these object provide access to the primitive data structure used in the Notion API as well as higher-level methods.</p>"},{"location":"reference/types/#notional.types.BlockRef","title":"<code>BlockRef</code>","text":"<p>               Bases: <code>ParentRef</code></p> <p>Reference a block.</p> Source code in <code>src/notional/types.py</code> <pre><code>class BlockRef(ParentRef, type=\"block_id\"):\n    \"\"\"Reference a block.\"\"\"\n\n    block_id: UUID\n\n    @classmethod\n    def __compose__(cls, block_ref):\n        \"\"\"Compose a BlockRef from the given reference object.\n\n        `block_ref` can be either a string, UUID, or block.\n        \"\"\"\n        ref = ObjectReference[block_ref]\n        return BlockRef(block_id=ref.id)\n</code></pre>"},{"location":"reference/types/#notional.types.BlockRef.__compose__","title":"<code>__compose__(block_ref)</code>  <code>classmethod</code>","text":"<p>Compose a BlockRef from the given reference object.</p> <p><code>block_ref</code> can be either a string, UUID, or block.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, block_ref):\n    \"\"\"Compose a BlockRef from the given reference object.\n\n    `block_ref` can be either a string, UUID, or block.\n    \"\"\"\n    ref = ObjectReference[block_ref]\n    return BlockRef(block_id=ref.id)\n</code></pre>"},{"location":"reference/types/#notional.types.BooleanFormula","title":"<code>BooleanFormula</code>","text":"<p>               Bases: <code>FormulaResult</code></p> <p>A Notion boolean formula result.</p> Source code in <code>src/notional/types.py</code> <pre><code>class BooleanFormula(FormulaResult, type=\"boolean\"):\n    \"\"\"A Notion boolean formula result.\"\"\"\n\n    boolean: Optional[bool] = None\n\n    @property\n    def Result(self):\n        \"\"\"Return the result of this BooleanFormula.\"\"\"\n        return self.boolean\n</code></pre>"},{"location":"reference/types/#notional.types.BooleanFormula.Result","title":"<code>Result</code>  <code>property</code>","text":"<p>Return the result of this BooleanFormula.</p>"},{"location":"reference/types/#notional.types.Checkbox","title":"<code>Checkbox</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Simple checkbox type; represented as a boolean.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Checkbox(NativeTypeMixin, PropertyValue, type=\"checkbox\"):\n    \"\"\"Simple checkbox type; represented as a boolean.\"\"\"\n\n    checkbox: Optional[bool] = None\n</code></pre>"},{"location":"reference/types/#notional.types.CreatedBy","title":"<code>CreatedBy</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>A Notion created-by property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class CreatedBy(PropertyValue, type=\"created_by\"):\n    \"\"\"A Notion created-by property value.\"\"\"\n\n    created_by: User\n\n    def __str__(self):\n        \"\"\"Return the contents of this property as a string.\"\"\"\n        return str(self.created_by)\n</code></pre>"},{"location":"reference/types/#notional.types.CreatedBy.__str__","title":"<code>__str__()</code>","text":"<p>Return the contents of this property as a string.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return the contents of this property as a string.\"\"\"\n    return str(self.created_by)\n</code></pre>"},{"location":"reference/types/#notional.types.CreatedTime","title":"<code>CreatedTime</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>A Notion created-time property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class CreatedTime(NativeTypeMixin, PropertyValue, type=\"created_time\"):\n    \"\"\"A Notion created-time property value.\"\"\"\n\n    created_time: datetime\n</code></pre>"},{"location":"reference/types/#notional.types.DatabaseRef","title":"<code>DatabaseRef</code>","text":"<p>               Bases: <code>ParentRef</code></p> <p>Reference a database.</p> Source code in <code>src/notional/types.py</code> <pre><code>class DatabaseRef(ParentRef, type=\"database_id\"):\n    \"\"\"Reference a database.\"\"\"\n\n    database_id: UUID\n\n    @classmethod\n    def __compose__(cls, db_ref):\n        \"\"\"Compose a DatabaseRef from the given reference object.\n\n        `db_ref` can be either a string, UUID, or database.\n        \"\"\"\n        ref = ObjectReference[db_ref]\n        return DatabaseRef(database_id=ref.id)\n</code></pre>"},{"location":"reference/types/#notional.types.DatabaseRef.__compose__","title":"<code>__compose__(db_ref)</code>  <code>classmethod</code>","text":"<p>Compose a DatabaseRef from the given reference object.</p> <p><code>db_ref</code> can be either a string, UUID, or database.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, db_ref):\n    \"\"\"Compose a DatabaseRef from the given reference object.\n\n    `db_ref` can be either a string, UUID, or database.\n    \"\"\"\n    ref = ObjectReference[db_ref]\n    return DatabaseRef(database_id=ref.id)\n</code></pre>"},{"location":"reference/types/#notional.types.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>Notion complex date type - may include timestamp and/or be a date range.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Date(PropertyValue, type=\"date\"):\n    \"\"\"Notion complex date type - may include timestamp and/or be a date range.\"\"\"\n\n    date: Optional[DateRange] = None\n\n    def __contains__(self, other):\n        \"\"\"Determine if the given date is in the range (inclusive) of this Date.\n\n        Raises ValueError if the Date object is not a range - e.g. has no end date.\n        \"\"\"\n\n        if not self.IsRange:\n            raise ValueError(\"This date is not a range\")\n\n        return self.Start &lt;= other &lt;= self.End\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return \"\" if self.date is None else str(self.date)\n\n    @classmethod\n    def __compose__(cls, start, end=None):\n        \"\"\"Create a new Date from the native values.\"\"\"\n        return cls(date=DateRange(start=start, end=end))\n\n    @property\n    def IsRange(self):\n        \"\"\"Determine if this object represents a date range (versus a single date).\"\"\"\n\n        if self.date is None:\n            return False\n\n        return self.date.end is not None\n\n    @property\n    def Start(self):\n        \"\"\"Return the start date of this property.\"\"\"\n        return None if self.date is None else self.date.start\n\n    @property\n    def End(self):\n        \"\"\"Return the end date of this property.\"\"\"\n        return None if self.date is None else self.date.end\n</code></pre>"},{"location":"reference/types/#notional.types.Date.End","title":"<code>End</code>  <code>property</code>","text":"<p>Return the end date of this property.</p>"},{"location":"reference/types/#notional.types.Date.IsRange","title":"<code>IsRange</code>  <code>property</code>","text":"<p>Determine if this object represents a date range (versus a single date).</p>"},{"location":"reference/types/#notional.types.Date.Start","title":"<code>Start</code>  <code>property</code>","text":"<p>Return the start date of this property.</p>"},{"location":"reference/types/#notional.types.Date.__compose__","title":"<code>__compose__(start, end=None)</code>  <code>classmethod</code>","text":"<p>Create a new Date from the native values.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, start, end=None):\n    \"\"\"Create a new Date from the native values.\"\"\"\n    return cls(date=DateRange(start=start, end=end))\n</code></pre>"},{"location":"reference/types/#notional.types.Date.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Determine if the given date is in the range (inclusive) of this Date.</p> <p>Raises ValueError if the Date object is not a range - e.g. has no end date.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __contains__(self, other):\n    \"\"\"Determine if the given date is in the range (inclusive) of this Date.\n\n    Raises ValueError if the Date object is not a range - e.g. has no end date.\n    \"\"\"\n\n    if not self.IsRange:\n        raise ValueError(\"This date is not a range\")\n\n    return self.Start &lt;= other &lt;= self.End\n</code></pre>"},{"location":"reference/types/#notional.types.Date.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return \"\" if self.date is None else str(self.date)\n</code></pre>"},{"location":"reference/types/#notional.types.DateFormula","title":"<code>DateFormula</code>","text":"<p>               Bases: <code>FormulaResult</code></p> <p>A Notion date formula result.</p> Source code in <code>src/notional/types.py</code> <pre><code>class DateFormula(FormulaResult, type=\"date\"):\n    \"\"\"A Notion date formula result.\"\"\"\n\n    date: Optional[DateRange] = None\n\n    @property\n    def Result(self):\n        \"\"\"Return the result of this DateFormula.\"\"\"\n        return self.date\n</code></pre>"},{"location":"reference/types/#notional.types.DateFormula.Result","title":"<code>Result</code>  <code>property</code>","text":"<p>Return the result of this DateFormula.</p>"},{"location":"reference/types/#notional.types.DateRange","title":"<code>DateRange</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>A Notion date range, with an optional end date.</p> Source code in <code>src/notional/types.py</code> <pre><code>class DateRange(GenericObject):\n    \"\"\"A Notion date range, with an optional end date.\"\"\"\n\n    start: Union[date, datetime]\n    end: Optional[Union[date, datetime]] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this object.\"\"\"\n\n        if self.end is None:\n            return f\"{self.start}\"\n\n        return f\"{self.start} :: {self.end}\"\n</code></pre>"},{"location":"reference/types/#notional.types.DateRange.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this object.\"\"\"\n\n    if self.end is None:\n        return f\"{self.start}\"\n\n    return f\"{self.start} :: {self.end}\"\n</code></pre>"},{"location":"reference/types/#notional.types.Email","title":"<code>Email</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion email type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Email(NativeTypeMixin, PropertyValue, type=\"email\"):\n    \"\"\"Notion email type.\"\"\"\n\n    email: Optional[str] = None\n</code></pre>"},{"location":"reference/types/#notional.types.EmojiObject","title":"<code>EmojiObject</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>A Notion emoji object.</p> Source code in <code>src/notional/types.py</code> <pre><code>class EmojiObject(TypedObject, type=\"emoji\"):\n    \"\"\"A Notion emoji object.\"\"\"\n\n    emoji: str\n\n    def __str__(self):\n        \"\"\"Return this EmojiObject as a simple string.\"\"\"\n        return self.emoji\n\n    @classmethod\n    def __compose__(cls, emoji):\n        \"\"\"Compose an EmojiObject from the given emoji string.\"\"\"\n        return EmojiObject(emoji=emoji)\n</code></pre>"},{"location":"reference/types/#notional.types.EmojiObject.__compose__","title":"<code>__compose__(emoji)</code>  <code>classmethod</code>","text":"<p>Compose an EmojiObject from the given emoji string.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, emoji):\n    \"\"\"Compose an EmojiObject from the given emoji string.\"\"\"\n    return EmojiObject(emoji=emoji)\n</code></pre>"},{"location":"reference/types/#notional.types.EmojiObject.__str__","title":"<code>__str__()</code>","text":"<p>Return this EmojiObject as a simple string.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return this EmojiObject as a simple string.\"\"\"\n    return self.emoji\n</code></pre>"},{"location":"reference/types/#notional.types.EquationObject","title":"<code>EquationObject</code>","text":"<p>               Bases: <code>RichTextObject</code></p> <p>Notion equation element.</p> Source code in <code>src/notional/types.py</code> <pre><code>class EquationObject(RichTextObject, type=\"equation\"):\n    \"\"\"Notion equation element.\"\"\"\n\n    class _NestedData(GenericObject):\n        expression: str\n\n    equation: _NestedData\n\n    def __str__(self):\n        \"\"\"Return a string representation of this object.\"\"\"\n\n        if self.equation is None:\n            return None\n\n        return self.equation.expression\n</code></pre>"},{"location":"reference/types/#notional.types.EquationObject.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this object.\"\"\"\n\n    if self.equation is None:\n        return None\n\n    return self.equation.expression\n</code></pre>"},{"location":"reference/types/#notional.types.ExternalFile","title":"<code>ExternalFile</code>","text":"<p>               Bases: <code>FileObject</code></p> <p>An external file object.</p> Source code in <code>src/notional/types.py</code> <pre><code>class ExternalFile(FileObject, type=\"external\"):\n    \"\"\"An external file object.\"\"\"\n\n    class _NestedData(GenericObject):\n        url: str\n\n    external: _NestedData\n\n    def __str__(self):\n        \"\"\"Return a string representation of this object.\"\"\"\n        name = super().__str__()\n\n        if self.external and self.external.url:\n            return f\"![{name}]({self.external.url})\"\n\n        return name\n\n    @classmethod\n    def __compose__(cls, url, name=None):\n        \"\"\"Create a new `ExternalFile` from the given URL.\"\"\"\n        return cls(name=name, external=cls._NestedData(url=url))\n</code></pre>"},{"location":"reference/types/#notional.types.ExternalFile.__compose__","title":"<code>__compose__(url, name=None)</code>  <code>classmethod</code>","text":"<p>Create a new <code>ExternalFile</code> from the given URL.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, url, name=None):\n    \"\"\"Create a new `ExternalFile` from the given URL.\"\"\"\n    return cls(name=name, external=cls._NestedData(url=url))\n</code></pre>"},{"location":"reference/types/#notional.types.ExternalFile.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this object.\"\"\"\n    name = super().__str__()\n\n    if self.external and self.external.url:\n        return f\"![{name}]({self.external.url})\"\n\n    return name\n</code></pre>"},{"location":"reference/types/#notional.types.FileObject","title":"<code>FileObject</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>A Notion file object.</p> <p>Depending on the context, a FileObject may require a name (such as in the <code>Files</code> property).  This makes the object hierarchy difficult, so here we simply allow <code>name</code> to be optional.  It is the responsibility of the caller to set <code>name</code> if required by the API.</p> Source code in <code>src/notional/types.py</code> <pre><code>class FileObject(TypedObject):\n    \"\"\"A Notion file object.\n\n    Depending on the context, a FileObject may require a name (such as in the `Files`\n    property).  This makes the object hierarchy difficult, so here we simply allow\n    `name` to be optional.  It is the responsibility of the caller to set `name` if\n    required by the API.\n    \"\"\"\n\n    name: Optional[str] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this object.\"\"\"\n        return self.name or \"__unknown__\"\n\n    @property\n    def URL(self):\n        \"\"\"Return the URL to this FileObject.\"\"\"\n        return self(\"url\")\n</code></pre>"},{"location":"reference/types/#notional.types.FileObject.URL","title":"<code>URL</code>  <code>property</code>","text":"<p>Return the URL to this FileObject.</p>"},{"location":"reference/types/#notional.types.FileObject.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this object.\"\"\"\n    return self.name or \"__unknown__\"\n</code></pre>"},{"location":"reference/types/#notional.types.Files","title":"<code>Files</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>Notion files type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Files(PropertyValue, type=\"files\"):\n    \"\"\"Notion files type.\"\"\"\n\n    files: List[FileObject] = []\n\n    def __contains__(self, other):\n        \"\"\"Determine if the given FileObject or name is in the property.\"\"\"\n\n        if self.files is None:\n            return False\n\n        for ref in self.files:\n            if ref == other:\n                return True\n\n            if ref.name == other:\n                return True\n\n        return False\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return \"; \".join([str(file) for file in self.files])\n\n    def __iter__(self):\n        \"\"\"Iterate over the FileObject's in this property.\"\"\"\n\n        if self.files is None:\n            return None\n\n        return iter(self.files)\n\n    def __len__(self):\n        \"\"\"Return the number of Files in this property.\"\"\"\n\n        return len(self.files)\n\n    def __getitem__(self, name):\n        \"\"\"Return the FileObject with the given name.\"\"\"\n\n        if self.files is None:\n            return None\n\n        for ref in self.files:\n            if ref.name == name:\n                return ref\n\n        raise AttributeError(\"No such file\")\n\n    def __iadd__(self, obj):\n        \"\"\"Append the given `FileObject` in place.\"\"\"\n\n        if obj in self:\n            raise ValueError(f\"Item exists: {obj}\")\n\n        self.append(obj)\n        return self\n\n    def __isub__(self, obj):\n        \"\"\"Remove the given `FileObject` in place.\"\"\"\n\n        if obj not in self:\n            raise ValueError(f\"No such item: {obj}\")\n\n        self.remove(obj)\n        return self\n\n    def append(self, obj):\n        \"\"\"Append the given file reference to this property.\n\n        :param ref: the `FileObject` to be added\n        \"\"\"\n        self.files.append(obj)\n\n    def remove(self, obj):\n        \"\"\"Remove the given file reference from this property.\n\n        :param ref: the `FileObject` to be removed\n        \"\"\"\n        self.files.remove(obj)\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Determine if the given FileObject or name is in the property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __contains__(self, other):\n    \"\"\"Determine if the given FileObject or name is in the property.\"\"\"\n\n    if self.files is None:\n        return False\n\n    for ref in self.files:\n        if ref == other:\n            return True\n\n        if ref.name == other:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__getitem__","title":"<code>__getitem__(name)</code>","text":"<p>Return the FileObject with the given name.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __getitem__(self, name):\n    \"\"\"Return the FileObject with the given name.\"\"\"\n\n    if self.files is None:\n        return None\n\n    for ref in self.files:\n        if ref.name == name:\n            return ref\n\n    raise AttributeError(\"No such file\")\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__iadd__","title":"<code>__iadd__(obj)</code>","text":"<p>Append the given <code>FileObject</code> in place.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iadd__(self, obj):\n    \"\"\"Append the given `FileObject` in place.\"\"\"\n\n    if obj in self:\n        raise ValueError(f\"Item exists: {obj}\")\n\n    self.append(obj)\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__isub__","title":"<code>__isub__(obj)</code>","text":"<p>Remove the given <code>FileObject</code> in place.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __isub__(self, obj):\n    \"\"\"Remove the given `FileObject` in place.\"\"\"\n\n    if obj not in self:\n        raise ValueError(f\"No such item: {obj}\")\n\n    self.remove(obj)\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the FileObject's in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the FileObject's in this property.\"\"\"\n\n    if self.files is None:\n        return None\n\n    return iter(self.files)\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of Files in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of Files in this property.\"\"\"\n\n    return len(self.files)\n</code></pre>"},{"location":"reference/types/#notional.types.Files.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return \"; \".join([str(file) for file in self.files])\n</code></pre>"},{"location":"reference/types/#notional.types.Files.append","title":"<code>append(obj)</code>","text":"<p>Append the given file reference to this property.</p> <p>:param ref: the <code>FileObject</code> to be added</p> Source code in <code>src/notional/types.py</code> <pre><code>def append(self, obj):\n    \"\"\"Append the given file reference to this property.\n\n    :param ref: the `FileObject` to be added\n    \"\"\"\n    self.files.append(obj)\n</code></pre>"},{"location":"reference/types/#notional.types.Files.remove","title":"<code>remove(obj)</code>","text":"<p>Remove the given file reference from this property.</p> <p>:param ref: the <code>FileObject</code> to be removed</p> Source code in <code>src/notional/types.py</code> <pre><code>def remove(self, obj):\n    \"\"\"Remove the given file reference from this property.\n\n    :param ref: the `FileObject` to be removed\n    \"\"\"\n    self.files.remove(obj)\n</code></pre>"},{"location":"reference/types/#notional.types.Formula","title":"<code>Formula</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>A Notion formula property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Formula(PropertyValue, type=\"formula\"):\n    \"\"\"A Notion formula property value.\"\"\"\n\n    formula: Optional[FormulaResult] = None\n\n    def __str__(self):\n        \"\"\"Return the result of this formula as a string.\"\"\"\n        return str(self.Result or \"\")\n\n    @property\n    def Result(self):\n        \"\"\"Return the result of this Formula in its native type.\"\"\"\n\n        if self.formula is None:\n            return None\n\n        return self.formula.Result\n</code></pre>"},{"location":"reference/types/#notional.types.Formula.Result","title":"<code>Result</code>  <code>property</code>","text":"<p>Return the result of this Formula in its native type.</p>"},{"location":"reference/types/#notional.types.Formula.__str__","title":"<code>__str__()</code>","text":"<p>Return the result of this formula as a string.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return the result of this formula as a string.\"\"\"\n    return str(self.Result or \"\")\n</code></pre>"},{"location":"reference/types/#notional.types.FormulaResult","title":"<code>FormulaResult</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>A Notion formula result.</p> <p>This object contains the result of the expression in the database properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class FormulaResult(TypedObject):\n    \"\"\"A Notion formula result.\n\n    This object contains the result of the expression in the database properties.\n    \"\"\"\n\n    def __str__(self):\n        \"\"\"Return the formula result as a string.\"\"\"\n        return self.Result or \"\"\n\n    @property\n    def Result(self):\n        \"\"\"Return the result of this FormulaResult.\"\"\"\n        raise NotImplementedError(\"Result unavailable\")\n</code></pre>"},{"location":"reference/types/#notional.types.FormulaResult.Result","title":"<code>Result</code>  <code>property</code>","text":"<p>Return the result of this FormulaResult.</p>"},{"location":"reference/types/#notional.types.FormulaResult.__str__","title":"<code>__str__()</code>","text":"<p>Return the formula result as a string.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return the formula result as a string.\"\"\"\n    return self.Result or \"\"\n</code></pre>"},{"location":"reference/types/#notional.types.HostedFile","title":"<code>HostedFile</code>","text":"<p>               Bases: <code>FileObject</code></p> <p>A Notion file object.</p> Source code in <code>src/notional/types.py</code> <pre><code>class HostedFile(FileObject, type=\"file\"):\n    \"\"\"A Notion file object.\"\"\"\n\n    class _NestedData(GenericObject):\n        url: str\n        expiry_time: Optional[datetime] = None\n\n    file: _NestedData\n</code></pre>"},{"location":"reference/types/#notional.types.LastEditedBy","title":"<code>LastEditedBy</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>A Notion last-edited-by property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class LastEditedBy(PropertyValue, type=\"last_edited_by\"):\n    \"\"\"A Notion last-edited-by property value.\"\"\"\n\n    last_edited_by: User\n\n    def __str__(self):\n        \"\"\"Return the contents of this property as a string.\"\"\"\n        return str(self.last_edited_by)\n</code></pre>"},{"location":"reference/types/#notional.types.LastEditedBy.__str__","title":"<code>__str__()</code>","text":"<p>Return the contents of this property as a string.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return the contents of this property as a string.\"\"\"\n    return str(self.last_edited_by)\n</code></pre>"},{"location":"reference/types/#notional.types.LastEditedTime","title":"<code>LastEditedTime</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>A Notion last-edited-time property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class LastEditedTime(NativeTypeMixin, PropertyValue, type=\"last_edited_time\"):\n    \"\"\"A Notion last-edited-time property value.\"\"\"\n\n    last_edited_time: datetime\n</code></pre>"},{"location":"reference/types/#notional.types.MentionData","title":"<code>MentionData</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Base class for typed <code>Mention</code> data objects.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionData(TypedObject):\n    \"\"\"Base class for typed `Mention` data objects.\"\"\"\n</code></pre>"},{"location":"reference/types/#notional.types.MentionDatabase","title":"<code>MentionDatabase</code>","text":"<p>               Bases: <code>MentionData</code></p> <p>Nested database information for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionDatabase(MentionData, type=\"database\"):\n    \"\"\"Nested database information for `Mention` properties.\"\"\"\n\n    database: ObjectReference\n\n    @classmethod\n    def __compose__(cls, page):\n        \"\"\"Build a `Mention` object for the specified database reference.\"\"\"\n\n        ref = ObjectReference[page]\n\n        return MentionObject(plain_text=str(ref), mention=MentionDatabase(database=ref))\n</code></pre>"},{"location":"reference/types/#notional.types.MentionDatabase.__compose__","title":"<code>__compose__(page)</code>  <code>classmethod</code>","text":"<p>Build a <code>Mention</code> object for the specified database reference.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, page):\n    \"\"\"Build a `Mention` object for the specified database reference.\"\"\"\n\n    ref = ObjectReference[page]\n\n    return MentionObject(plain_text=str(ref), mention=MentionDatabase(database=ref))\n</code></pre>"},{"location":"reference/types/#notional.types.MentionDate","title":"<code>MentionDate</code>","text":"<p>               Bases: <code>MentionData</code></p> <p>Nested date data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionDate(MentionData, type=\"date\"):\n    \"\"\"Nested date data for `Mention` properties.\"\"\"\n\n    date: DateRange\n\n    @classmethod\n    def __compose__(cls, start, end=None):\n        \"\"\"Build a `Mention` object for the specified URL.\"\"\"\n\n        date_obj = DateRange(start=start, end=end)\n\n        return MentionObject(\n            plain_text=str(date_obj), mention=MentionDate(date=date_obj)\n        )\n</code></pre>"},{"location":"reference/types/#notional.types.MentionDate.__compose__","title":"<code>__compose__(start, end=None)</code>  <code>classmethod</code>","text":"<p>Build a <code>Mention</code> object for the specified URL.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, start, end=None):\n    \"\"\"Build a `Mention` object for the specified URL.\"\"\"\n\n    date_obj = DateRange(start=start, end=end)\n\n    return MentionObject(\n        plain_text=str(date_obj), mention=MentionDate(date=date_obj)\n    )\n</code></pre>"},{"location":"reference/types/#notional.types.MentionLinkPreview","title":"<code>MentionLinkPreview</code>","text":"<p>               Bases: <code>MentionData</code></p> <p>Nested url data for <code>Mention</code> properties.</p> <p>These objects cannot be created via the API.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionLinkPreview(MentionData, type=\"link_preview\"):\n    \"\"\"Nested url data for `Mention` properties.\n\n    These objects cannot be created via the API.\n    \"\"\"\n\n    class _NestedData(GenericObject):\n        url: str\n\n    link_preview: _NestedData\n</code></pre>"},{"location":"reference/types/#notional.types.MentionObject","title":"<code>MentionObject</code>","text":"<p>               Bases: <code>RichTextObject</code></p> <p>Notion mention element.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionObject(RichTextObject, type=\"mention\"):\n    \"\"\"Notion mention element.\"\"\"\n\n    mention: MentionData\n</code></pre>"},{"location":"reference/types/#notional.types.MentionPage","title":"<code>MentionPage</code>","text":"<p>               Bases: <code>MentionData</code></p> <p>Nested page data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionPage(MentionData, type=\"page\"):\n    \"\"\"Nested page data for `Mention` properties.\"\"\"\n\n    page: ObjectReference\n\n    @classmethod\n    def __compose__(cls, page_ref):\n        \"\"\"Build a `Mention` object for the specified page reference.\"\"\"\n\n        ref = ObjectReference[page_ref]\n\n        return MentionObject(plain_text=str(ref), mention=MentionPage(page=ref))\n</code></pre>"},{"location":"reference/types/#notional.types.MentionPage.__compose__","title":"<code>__compose__(page_ref)</code>  <code>classmethod</code>","text":"<p>Build a <code>Mention</code> object for the specified page reference.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, page_ref):\n    \"\"\"Build a `Mention` object for the specified page reference.\"\"\"\n\n    ref = ObjectReference[page_ref]\n\n    return MentionObject(plain_text=str(ref), mention=MentionPage(page=ref))\n</code></pre>"},{"location":"reference/types/#notional.types.MentionTemplate","title":"<code>MentionTemplate</code>","text":"<p>               Bases: <code>MentionData</code></p> <p>Nested template data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionTemplate(MentionData, type=\"template_mention\"):\n    \"\"\"Nested template data for `Mention` properties.\"\"\"\n\n    template_mention: MentionTemplateData\n</code></pre>"},{"location":"reference/types/#notional.types.MentionTemplateData","title":"<code>MentionTemplateData</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Nested template data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionTemplateData(TypedObject):\n    \"\"\"Nested template data for `Mention` properties.\"\"\"\n</code></pre>"},{"location":"reference/types/#notional.types.MentionTemplateDate","title":"<code>MentionTemplateDate</code>","text":"<p>               Bases: <code>MentionTemplateData</code></p> <p>Nested date template data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionTemplateDate(MentionTemplateData, type=\"template_mention_date\"):\n    \"\"\"Nested date template data for `Mention` properties.\"\"\"\n\n    template_mention_date: str\n</code></pre>"},{"location":"reference/types/#notional.types.MentionTemplateUser","title":"<code>MentionTemplateUser</code>","text":"<p>               Bases: <code>MentionTemplateData</code></p> <p>Nested user template data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionTemplateUser(MentionTemplateData, type=\"template_mention_user\"):\n    \"\"\"Nested user template data for `Mention` properties.\"\"\"\n\n    template_mention_user: str\n</code></pre>"},{"location":"reference/types/#notional.types.MentionUser","title":"<code>MentionUser</code>","text":"<p>               Bases: <code>MentionData</code></p> <p>Nested user data for <code>Mention</code> properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MentionUser(MentionData, type=\"user\"):\n    \"\"\"Nested user data for `Mention` properties.\"\"\"\n\n    user: User\n\n    @classmethod\n    def __compose__(cls, user: User):\n        \"\"\"Build a `Mention` object for the specified user.\n\n        The `id` field must be set for the given User.  Other fields may cause errors\n        if they do not match the specific type returned from the API.\n        \"\"\"\n\n        return MentionObject(plain_text=str(user), mention=MentionUser(user=user))\n</code></pre>"},{"location":"reference/types/#notional.types.MentionUser.__compose__","title":"<code>__compose__(user)</code>  <code>classmethod</code>","text":"<p>Build a <code>Mention</code> object for the specified user.</p> <p>The <code>id</code> field must be set for the given User.  Other fields may cause errors if they do not match the specific type returned from the API.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, user: User):\n    \"\"\"Build a `Mention` object for the specified user.\n\n    The `id` field must be set for the given User.  Other fields may cause errors\n    if they do not match the specific type returned from the API.\n    \"\"\"\n\n    return MentionObject(plain_text=str(user), mention=MentionUser(user=user))\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect","title":"<code>MultiSelect</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>Notion multi-select type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class MultiSelect(PropertyValue, type=\"multi_select\"):\n    \"\"\"Notion multi-select type.\"\"\"\n\n    multi_select: List[SelectValue] = []\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return \", \".join(self.Values)\n\n    def __len__(self):\n        \"\"\"Count the number of selected values.\"\"\"\n        return len(self.multi_select)\n\n    def __getitem__(self, index):\n        \"\"\"Return the SelectValue object at the given index.\"\"\"\n\n        if self.multi_select is None:\n            raise IndexError(\"empty property\")\n\n        if index &gt; len(self.multi_select):\n            raise IndexError(\"index out of range\")\n\n        return self.multi_select[index]\n\n    def __iadd__(self, other):\n        \"\"\"Add the given option to this MultiSelect.\"\"\"\n\n        if other in self:\n            raise ValueError(f\"Duplicate item: {other}\")\n\n        self.append(other)\n\n        return self\n\n    def __isub__(self, other):\n        \"\"\"Remove the given value from this MultiSelect.\"\"\"\n\n        if other not in self:\n            raise ValueError(f\"No such item: {other}\")\n\n        self.remove(other)\n\n        return self\n\n    def __contains__(self, name):\n        \"\"\"Determine if the given name is in this MultiSelect.\n\n        To avoid confusion, only names are considered for comparison, not ID's.\n        \"\"\"\n\n        for opt in self.multi_select:\n            if opt.name == name:\n                return True\n\n        return False\n\n    def __iter__(self):\n        \"\"\"Iterate over the SelectValue's in this property.\"\"\"\n\n        if self.multi_select is None:\n            return None\n\n        return iter(self.multi_select)\n\n    @classmethod\n    def __compose__(cls, *values):\n        \"\"\"Initialize a new MultiSelect from the given value(s).\"\"\"\n        select = [SelectValue[value] for value in values if value is not None]\n\n        return cls(multi_select=select)\n\n    def append(self, *values):\n        \"\"\"Add selected values to this MultiSelect.\"\"\"\n\n        for value in values:\n            if value is None:\n                raise ValueError(\"'None' is an invalid value\")\n\n            if value not in self:\n                self.multi_select.append(SelectValue[value])\n\n    def remove(self, *values):\n        \"\"\"Remove selected values from this MultiSelect.\"\"\"\n\n        self.multi_select = [opt for opt in self.multi_select if opt.name not in values]\n\n    @property\n    def Values(self):\n        \"\"\"Return the names of each value in this MultiSelect as a list.\"\"\"\n\n        if self.multi_select is None:\n            return None\n\n        return [str(val) for val in self.multi_select if val.name is not None]\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.Values","title":"<code>Values</code>  <code>property</code>","text":"<p>Return the names of each value in this MultiSelect as a list.</p>"},{"location":"reference/types/#notional.types.MultiSelect.__compose__","title":"<code>__compose__(*values)</code>  <code>classmethod</code>","text":"<p>Initialize a new MultiSelect from the given value(s).</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, *values):\n    \"\"\"Initialize a new MultiSelect from the given value(s).\"\"\"\n    select = [SelectValue[value] for value in values if value is not None]\n\n    return cls(multi_select=select)\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Determine if the given name is in this MultiSelect.</p> <p>To avoid confusion, only names are considered for comparison, not ID's.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __contains__(self, name):\n    \"\"\"Determine if the given name is in this MultiSelect.\n\n    To avoid confusion, only names are considered for comparison, not ID's.\n    \"\"\"\n\n    for opt in self.multi_select:\n        if opt.name == name:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Return the SelectValue object at the given index.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Return the SelectValue object at the given index.\"\"\"\n\n    if self.multi_select is None:\n        raise IndexError(\"empty property\")\n\n    if index &gt; len(self.multi_select):\n        raise IndexError(\"index out of range\")\n\n    return self.multi_select[index]\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Add the given option to this MultiSelect.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iadd__(self, other):\n    \"\"\"Add the given option to this MultiSelect.\"\"\"\n\n    if other in self:\n        raise ValueError(f\"Duplicate item: {other}\")\n\n    self.append(other)\n\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__isub__","title":"<code>__isub__(other)</code>","text":"<p>Remove the given value from this MultiSelect.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __isub__(self, other):\n    \"\"\"Remove the given value from this MultiSelect.\"\"\"\n\n    if other not in self:\n        raise ValueError(f\"No such item: {other}\")\n\n    self.remove(other)\n\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the SelectValue's in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the SelectValue's in this property.\"\"\"\n\n    if self.multi_select is None:\n        return None\n\n    return iter(self.multi_select)\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__len__","title":"<code>__len__()</code>","text":"<p>Count the number of selected values.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __len__(self):\n    \"\"\"Count the number of selected values.\"\"\"\n    return len(self.multi_select)\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return \", \".join(self.Values)\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.append","title":"<code>append(*values)</code>","text":"<p>Add selected values to this MultiSelect.</p> Source code in <code>src/notional/types.py</code> <pre><code>def append(self, *values):\n    \"\"\"Add selected values to this MultiSelect.\"\"\"\n\n    for value in values:\n        if value is None:\n            raise ValueError(\"'None' is an invalid value\")\n\n        if value not in self:\n            self.multi_select.append(SelectValue[value])\n</code></pre>"},{"location":"reference/types/#notional.types.MultiSelect.remove","title":"<code>remove(*values)</code>","text":"<p>Remove selected values from this MultiSelect.</p> Source code in <code>src/notional/types.py</code> <pre><code>def remove(self, *values):\n    \"\"\"Remove selected values from this MultiSelect.\"\"\"\n\n    self.multi_select = [opt for opt in self.multi_select if opt.name not in values]\n</code></pre>"},{"location":"reference/types/#notional.types.NativeTypeMixin","title":"<code>NativeTypeMixin</code>","text":"<p>Mixin class for properties that can be represented as native Python types.</p> Source code in <code>src/notional/types.py</code> <pre><code>class NativeTypeMixin:\n    \"\"\"Mixin class for properties that can be represented as native Python types.\"\"\"\n\n    def __str__(self):\n        \"\"\"Return a string representation of this object.\"\"\"\n\n        value = self.Value\n\n        if value is None:\n            return \"\"\n\n        return str(value)\n\n    def __eq__(self, other):\n        \"\"\"Determine if this property is equal to the given object.\"\"\"\n\n        # if `other` is a NativeTypeMixin, this comparrison will call __eq__ on that\n        # object using this objects `Value` as the value for `other` (allowing callers\n        # to compare using either native types or NativeTypeMixin's)\n\n        return other == self.Value\n\n    def __ne__(self, other):\n        \"\"\"Determine if this property is not equal to the given object.\"\"\"\n        return not self.__eq__(other)\n\n    @classmethod\n    def __compose__(cls, value):\n        \"\"\"Build the property value from the native Python value.\"\"\"\n\n        # use type-name field to instantiate the class when possible\n        if hasattr(cls, \"type\"):\n            return cls(**{cls.type: value})\n\n        raise NotImplementedError()\n\n    @property\n    def Value(self):\n        \"\"\"Get the current value of this property as a native Python type.\"\"\"\n\n        cls = self.__class__\n\n        # check to see if the object has a field with the type-name\n        # (this is assigned by TypedObject during subclass creation)\n        if hasattr(cls, \"type\") and hasattr(self, cls.type):\n            return getattr(self, cls.type)\n\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/types/#notional.types.NativeTypeMixin.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Get the current value of this property as a native Python type.</p>"},{"location":"reference/types/#notional.types.NativeTypeMixin.__compose__","title":"<code>__compose__(value)</code>  <code>classmethod</code>","text":"<p>Build the property value from the native Python value.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, value):\n    \"\"\"Build the property value from the native Python value.\"\"\"\n\n    # use type-name field to instantiate the class when possible\n    if hasattr(cls, \"type\"):\n        return cls(**{cls.type: value})\n\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/types/#notional.types.NativeTypeMixin.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Determine if this property is equal to the given object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Determine if this property is equal to the given object.\"\"\"\n\n    # if `other` is a NativeTypeMixin, this comparrison will call __eq__ on that\n    # object using this objects `Value` as the value for `other` (allowing callers\n    # to compare using either native types or NativeTypeMixin's)\n\n    return other == self.Value\n</code></pre>"},{"location":"reference/types/#notional.types.NativeTypeMixin.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Determine if this property is not equal to the given object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"Determine if this property is not equal to the given object.\"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/types/#notional.types.NativeTypeMixin.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this object.\"\"\"\n\n    value = self.Value\n\n    if value is None:\n        return \"\"\n\n    return str(value)\n</code></pre>"},{"location":"reference/types/#notional.types.Number","title":"<code>Number</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Simple number type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Number(NativeTypeMixin, PropertyValue, type=\"number\"):\n    \"\"\"Simple number type.\"\"\"\n\n    number: Optional[Union[float, int]] = None\n\n    def __float__(self):\n        \"\"\"Return the Number as a `float`.\"\"\"\n\n        if self.number is None:\n            raise ValueError(\"Cannot convert 'None' to float\")\n\n        return float(self.number)\n\n    def __int__(self):\n        \"\"\"Return the Number as an `int`.\"\"\"\n\n        if self.number is None:\n            raise ValueError(\"Cannot convert 'None' to int\")\n\n        return int(self.number)\n\n    def __iadd__(self, other):\n        \"\"\"Add the given value to this Number.\"\"\"\n\n        if isinstance(other, Number):\n            self.number += other.Value\n        else:\n            self.number += other\n\n        return self\n\n    def __isub__(self, other):\n        \"\"\"Subtract the given value from this Number.\"\"\"\n\n        if isinstance(other, Number):\n            self.number -= other.Value\n        else:\n            self.number -= other\n\n        return self\n\n    def __add__(self, other):\n        \"\"\"Add the value of `other` and returns the result as a Number.\"\"\"\n        return Number[other + self.Value]\n\n    def __sub__(self, other):\n        \"\"\"Subtract the value of `other` and returns the result as a Number.\"\"\"\n        return Number[self.Value - float(other)]\n\n    def __mul__(self, other):\n        \"\"\"Multiply the value of `other` and returns the result as a Number.\"\"\"\n        return Number[other * self.Value]\n\n    def __le__(self, other):\n        \"\"\"Return `True` if this `Number` is less-than-or-equal-to `other`.\"\"\"\n        return self &lt; other or self == other\n\n    def __lt__(self, other):\n        \"\"\"Return `True` if this `Number` is less-than `other`.\"\"\"\n        return other &gt; self.Value\n\n    def __ge__(self, other):\n        \"\"\"Return `True` if this `Number` is greater-than-or-equal-to `other`.\"\"\"\n        return self &gt; other or self == other\n\n    def __gt__(self, other):\n        \"\"\"Return `True` if this `Number` is greater-than `other`.\"\"\"\n        return other &lt; self.Value\n\n    @property\n    def Value(self):\n        \"\"\"Get the current value of this property as a native Python number.\"\"\"\n        return self.number\n</code></pre>"},{"location":"reference/types/#notional.types.Number.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Get the current value of this property as a native Python number.</p>"},{"location":"reference/types/#notional.types.Number.__add__","title":"<code>__add__(other)</code>","text":"<p>Add the value of <code>other</code> and returns the result as a Number.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __add__(self, other):\n    \"\"\"Add the value of `other` and returns the result as a Number.\"\"\"\n    return Number[other + self.Value]\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__float__","title":"<code>__float__()</code>","text":"<p>Return the Number as a <code>float</code>.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __float__(self):\n    \"\"\"Return the Number as a `float`.\"\"\"\n\n    if self.number is None:\n        raise ValueError(\"Cannot convert 'None' to float\")\n\n    return float(self.number)\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Return <code>True</code> if this <code>Number</code> is greater-than-or-equal-to <code>other</code>.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __ge__(self, other):\n    \"\"\"Return `True` if this `Number` is greater-than-or-equal-to `other`.\"\"\"\n    return self &gt; other or self == other\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Return <code>True</code> if this <code>Number</code> is greater-than <code>other</code>.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __gt__(self, other):\n    \"\"\"Return `True` if this `Number` is greater-than `other`.\"\"\"\n    return other &lt; self.Value\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Add the given value to this Number.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iadd__(self, other):\n    \"\"\"Add the given value to this Number.\"\"\"\n\n    if isinstance(other, Number):\n        self.number += other.Value\n    else:\n        self.number += other\n\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__int__","title":"<code>__int__()</code>","text":"<p>Return the Number as an <code>int</code>.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __int__(self):\n    \"\"\"Return the Number as an `int`.\"\"\"\n\n    if self.number is None:\n        raise ValueError(\"Cannot convert 'None' to int\")\n\n    return int(self.number)\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__isub__","title":"<code>__isub__(other)</code>","text":"<p>Subtract the given value from this Number.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __isub__(self, other):\n    \"\"\"Subtract the given value from this Number.\"\"\"\n\n    if isinstance(other, Number):\n        self.number -= other.Value\n    else:\n        self.number -= other\n\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__le__","title":"<code>__le__(other)</code>","text":"<p>Return <code>True</code> if this <code>Number</code> is less-than-or-equal-to <code>other</code>.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __le__(self, other):\n    \"\"\"Return `True` if this `Number` is less-than-or-equal-to `other`.\"\"\"\n    return self &lt; other or self == other\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return <code>True</code> if this <code>Number</code> is less-than <code>other</code>.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __lt__(self, other):\n    \"\"\"Return `True` if this `Number` is less-than `other`.\"\"\"\n    return other &gt; self.Value\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiply the value of <code>other</code> and returns the result as a Number.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __mul__(self, other):\n    \"\"\"Multiply the value of `other` and returns the result as a Number.\"\"\"\n    return Number[other * self.Value]\n</code></pre>"},{"location":"reference/types/#notional.types.Number.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtract the value of <code>other</code> and returns the result as a Number.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"Subtract the value of `other` and returns the result as a Number.\"\"\"\n    return Number[self.Value - float(other)]\n</code></pre>"},{"location":"reference/types/#notional.types.NumberFormula","title":"<code>NumberFormula</code>","text":"<p>               Bases: <code>FormulaResult</code></p> <p>A Notion number formula result.</p> Source code in <code>src/notional/types.py</code> <pre><code>class NumberFormula(FormulaResult, type=\"number\"):\n    \"\"\"A Notion number formula result.\"\"\"\n\n    number: Optional[Union[float, int]] = None\n\n    @property\n    def Result(self):\n        \"\"\"Return the result of this NumberFormula.\"\"\"\n        return self.number\n</code></pre>"},{"location":"reference/types/#notional.types.NumberFormula.Result","title":"<code>Result</code>  <code>property</code>","text":"<p>Return the result of this NumberFormula.</p>"},{"location":"reference/types/#notional.types.ObjectReference","title":"<code>ObjectReference</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>A general-purpose object reference in the Notion API.</p> Source code in <code>src/notional/types.py</code> <pre><code>class ObjectReference(GenericObject):\n    \"\"\"A general-purpose object reference in the Notion API.\"\"\"\n\n    id: UUID\n\n    @classmethod\n    def __compose__(cls, ref):\n        \"\"\"Compose an ObjectReference from the given reference.\n\n        `ref` may be a `UUID`, `str`, `ParentRef` or `GenericObject` with an `id`.\n\n        Strings may be either UUID's or URL's to Notion content.\n        \"\"\"\n\n        if isinstance(ref, cls):\n            return ref.copy(deep=True)\n\n        if isinstance(ref, ParentRef):\n            # ParentRef's are typed-objects with a nested UUID\n            return ObjectReference(id=ref())\n\n        if isinstance(ref, GenericObject) and hasattr(ref, \"id\"):\n            # re-compose the ObjectReference from the internal ID\n            return ObjectReference[ref.id]\n\n        if isinstance(ref, UUID):\n            return ObjectReference(id=ref)\n\n        if isinstance(ref, str):\n            ref = util.extract_id_from_string(ref)\n\n            if ref is not None:\n                return ObjectReference(id=UUID(ref))\n\n        raise ValueError(\"Unrecognized 'ref' attribute\")\n\n    @property\n    def URL(self):\n        \"\"\"Return the Notion URL for this object reference.\n\n        Note: this is a convenience property only.  It does not guarantee that the\n        URL exists or that it is accessible by the integration.\n        \"\"\"\n        return helpers.get_url(self.id)\n</code></pre>"},{"location":"reference/types/#notional.types.ObjectReference.URL","title":"<code>URL</code>  <code>property</code>","text":"<p>Return the Notion URL for this object reference.</p> <p>Note: this is a convenience property only.  It does not guarantee that the URL exists or that it is accessible by the integration.</p>"},{"location":"reference/types/#notional.types.ObjectReference.__compose__","title":"<code>__compose__(ref)</code>  <code>classmethod</code>","text":"<p>Compose an ObjectReference from the given reference.</p> <p><code>ref</code> may be a <code>UUID</code>, <code>str</code>, <code>ParentRef</code> or <code>GenericObject</code> with an <code>id</code>.</p> <p>Strings may be either UUID's or URL's to Notion content.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, ref):\n    \"\"\"Compose an ObjectReference from the given reference.\n\n    `ref` may be a `UUID`, `str`, `ParentRef` or `GenericObject` with an `id`.\n\n    Strings may be either UUID's or URL's to Notion content.\n    \"\"\"\n\n    if isinstance(ref, cls):\n        return ref.copy(deep=True)\n\n    if isinstance(ref, ParentRef):\n        # ParentRef's are typed-objects with a nested UUID\n        return ObjectReference(id=ref())\n\n    if isinstance(ref, GenericObject) and hasattr(ref, \"id\"):\n        # re-compose the ObjectReference from the internal ID\n        return ObjectReference[ref.id]\n\n    if isinstance(ref, UUID):\n        return ObjectReference(id=ref)\n\n    if isinstance(ref, str):\n        ref = util.extract_id_from_string(ref)\n\n        if ref is not None:\n            return ObjectReference(id=UUID(ref))\n\n    raise ValueError(\"Unrecognized 'ref' attribute\")\n</code></pre>"},{"location":"reference/types/#notional.types.PageRef","title":"<code>PageRef</code>","text":"<p>               Bases: <code>ParentRef</code></p> <p>Reference a page.</p> Source code in <code>src/notional/types.py</code> <pre><code>class PageRef(ParentRef, type=\"page_id\"):\n    \"\"\"Reference a page.\"\"\"\n\n    page_id: UUID\n\n    @classmethod\n    def __compose__(cls, page_ref):\n        \"\"\"Compose a PageRef from the given reference object.\n\n        `page_ref` can be either a string, UUID, or page.\n        \"\"\"\n        ref = ObjectReference[page_ref]\n        return PageRef(page_id=ref.id)\n</code></pre>"},{"location":"reference/types/#notional.types.PageRef.__compose__","title":"<code>__compose__(page_ref)</code>  <code>classmethod</code>","text":"<p>Compose a PageRef from the given reference object.</p> <p><code>page_ref</code> can be either a string, UUID, or page.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, page_ref):\n    \"\"\"Compose a PageRef from the given reference object.\n\n    `page_ref` can be either a string, UUID, or page.\n    \"\"\"\n    ref = ObjectReference[page_ref]\n    return PageRef(page_id=ref.id)\n</code></pre>"},{"location":"reference/types/#notional.types.ParentRef","title":"<code>ParentRef</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Reference another block as a parent.</p> Source code in <code>src/notional/types.py</code> <pre><code>class ParentRef(TypedObject):\n    \"\"\"Reference another block as a parent.\"\"\"\n</code></pre>"},{"location":"reference/types/#notional.types.People","title":"<code>People</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>Notion people type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class People(PropertyValue, type=\"people\"):\n    \"\"\"Notion people type.\"\"\"\n\n    people: List[User] = []\n\n    def __iter__(self):\n        \"\"\"Iterate over the User's in this property.\"\"\"\n\n        if self.people is None:\n            return None\n\n        return iter(self.people)\n\n    def __contains__(self, other):\n        \"\"\"Determine if the given User or name is in this People.\n\n        To avoid confusion, only names are considered for comparison (not ID's).\n        \"\"\"\n\n        for user in self.people:\n            if user == other:\n                return True\n\n            if user.name == other:\n                return True\n\n        return False\n\n    def __len__(self):\n        \"\"\"Return the number of People in this property.\"\"\"\n\n        return len(self.people)\n\n    def __getitem__(self, index):\n        \"\"\"Return the People object at the given index.\"\"\"\n\n        if self.people is None:\n            raise IndexError(\"empty property\")\n\n        if index &gt; len(self.people):\n            raise IndexError(\"index out of range\")\n\n        return self.people[index]\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return \", \".join([str(user) for user in self.people])\n</code></pre>"},{"location":"reference/types/#notional.types.People.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Determine if the given User or name is in this People.</p> <p>To avoid confusion, only names are considered for comparison (not ID's).</p> Source code in <code>src/notional/types.py</code> <pre><code>def __contains__(self, other):\n    \"\"\"Determine if the given User or name is in this People.\n\n    To avoid confusion, only names are considered for comparison (not ID's).\n    \"\"\"\n\n    for user in self.people:\n        if user == other:\n            return True\n\n        if user.name == other:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/types/#notional.types.People.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Return the People object at the given index.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Return the People object at the given index.\"\"\"\n\n    if self.people is None:\n        raise IndexError(\"empty property\")\n\n    if index &gt; len(self.people):\n        raise IndexError(\"index out of range\")\n\n    return self.people[index]\n</code></pre>"},{"location":"reference/types/#notional.types.People.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the User's in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the User's in this property.\"\"\"\n\n    if self.people is None:\n        return None\n\n    return iter(self.people)\n</code></pre>"},{"location":"reference/types/#notional.types.People.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of People in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of People in this property.\"\"\"\n\n    return len(self.people)\n</code></pre>"},{"location":"reference/types/#notional.types.People.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return \", \".join([str(user) for user in self.people])\n</code></pre>"},{"location":"reference/types/#notional.types.PhoneNumber","title":"<code>PhoneNumber</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion phone type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class PhoneNumber(NativeTypeMixin, PropertyValue, type=\"phone_number\"):\n    \"\"\"Notion phone type.\"\"\"\n\n    phone_number: Optional[str] = None\n</code></pre>"},{"location":"reference/types/#notional.types.PropertyItem","title":"<code>PropertyItem</code>","text":"<p>               Bases: <code>PropertyValue</code>, <code>NotionObject</code></p> <p>A <code>PropertyItem</code> returned by the Notion API.</p> <p>Basic property items have a similar schema to corresponding property values.  As a result, these items share the <code>PropertyValue</code> type definitions.</p> <p>This class provides a placeholder for parsing property items, however objects parse by this class will likely be <code>PropertyValue</code>'s instead.</p> Source code in <code>src/notional/types.py</code> <pre><code>class PropertyItem(PropertyValue, NotionObject, object=\"property_item\"):\n    \"\"\"A `PropertyItem` returned by the Notion API.\n\n    Basic property items have a similar schema to corresponding property values.  As a\n    result, these items share the `PropertyValue` type definitions.\n\n    This class provides a placeholder for parsing property items, however objects\n    parse by this class will likely be `PropertyValue`'s instead.\n    \"\"\"\n</code></pre>"},{"location":"reference/types/#notional.types.PropertyValue","title":"<code>PropertyValue</code>","text":"<p>               Bases: <code>TypedObject</code></p> <p>Base class for Notion property values.</p> Source code in <code>src/notional/types.py</code> <pre><code>class PropertyValue(TypedObject):\n    \"\"\"Base class for Notion property values.\"\"\"\n\n    id: Optional[str] = None\n</code></pre>"},{"location":"reference/types/#notional.types.Relation","title":"<code>Relation</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>A Notion relation property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Relation(PropertyValue, type=\"relation\"):\n    \"\"\"A Notion relation property value.\"\"\"\n\n    relation: List[ObjectReference] = []\n    has_more: bool = False\n\n    @classmethod\n    def __compose__(cls, *pages):\n        \"\"\"Return a `Relation` property with the specified pages.\"\"\"\n        return cls(relation=[ObjectReference[page] for page in pages])\n\n    def __contains__(self, page):\n        \"\"\"Determine if the given page is in this Relation.\"\"\"\n        return ObjectReference[page] in self.relation\n\n    def __iter__(self):\n        \"\"\"Iterate over the ObjectReference's in this property.\"\"\"\n\n        if self.relation is None:\n            return None\n\n        return iter(self.relation)\n\n    def __len__(self):\n        \"\"\"Return the number of ObjectReference's in this property.\"\"\"\n\n        return len(self.relation)\n\n    def __getitem__(self, index):\n        \"\"\"Return the ObjectReference object at the given index.\"\"\"\n\n        if self.relation is None:\n            raise IndexError(\"empty property\")\n\n        if index &gt; len(self.relation):\n            raise IndexError(\"index out of range\")\n\n        return self.relation[index]\n\n    def __iadd__(self, page):\n        \"\"\"Add the given page to this Relation in place.\"\"\"\n\n        ref = ObjectReference[page]\n\n        if ref in self.relation:\n            raise ValueError(f\"Duplicate item: {ref.id}\")\n\n        self.relation.append(ref)\n\n        return self\n\n    def __isub__(self, page):\n        \"\"\"Remove the given page from this Relation in place.\"\"\"\n\n        ref = ObjectReference[page]\n\n        if ref in self.relation:\n            raise ValueError(f\"No such item: {ref.id}\")\n\n        self.relation.remove(ref)\n\n        return self\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__compose__","title":"<code>__compose__(*pages)</code>  <code>classmethod</code>","text":"<p>Return a <code>Relation</code> property with the specified pages.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, *pages):\n    \"\"\"Return a `Relation` property with the specified pages.\"\"\"\n    return cls(relation=[ObjectReference[page] for page in pages])\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__contains__","title":"<code>__contains__(page)</code>","text":"<p>Determine if the given page is in this Relation.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __contains__(self, page):\n    \"\"\"Determine if the given page is in this Relation.\"\"\"\n    return ObjectReference[page] in self.relation\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Return the ObjectReference object at the given index.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Return the ObjectReference object at the given index.\"\"\"\n\n    if self.relation is None:\n        raise IndexError(\"empty property\")\n\n    if index &gt; len(self.relation):\n        raise IndexError(\"index out of range\")\n\n    return self.relation[index]\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__iadd__","title":"<code>__iadd__(page)</code>","text":"<p>Add the given page to this Relation in place.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iadd__(self, page):\n    \"\"\"Add the given page to this Relation in place.\"\"\"\n\n    ref = ObjectReference[page]\n\n    if ref in self.relation:\n        raise ValueError(f\"Duplicate item: {ref.id}\")\n\n    self.relation.append(ref)\n\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__isub__","title":"<code>__isub__(page)</code>","text":"<p>Remove the given page from this Relation in place.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __isub__(self, page):\n    \"\"\"Remove the given page from this Relation in place.\"\"\"\n\n    ref = ObjectReference[page]\n\n    if ref in self.relation:\n        raise ValueError(f\"No such item: {ref.id}\")\n\n    self.relation.remove(ref)\n\n    return self\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the ObjectReference's in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate over the ObjectReference's in this property.\"\"\"\n\n    if self.relation is None:\n        return None\n\n    return iter(self.relation)\n</code></pre>"},{"location":"reference/types/#notional.types.Relation.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of ObjectReference's in this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of ObjectReference's in this property.\"\"\"\n\n    return len(self.relation)\n</code></pre>"},{"location":"reference/types/#notional.types.RichText","title":"<code>RichText</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion rich text type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class RichText(NativeTypeMixin, PropertyValue, type=\"rich_text\"):\n    \"\"\"Notion rich text type.\"\"\"\n\n    rich_text: List[RichTextObject] = []\n\n    def __len__(self):\n        \"\"\"Return the number of object in the RichText object.\"\"\"\n        return len(self.rich_text)\n\n    @classmethod\n    def __compose__(cls, *text):\n        \"\"\"Create a new `RichText` property from the given strings.\"\"\"\n        return cls(rich_text=rich_text(*text))\n\n    @property\n    def Value(self):\n        \"\"\"Return the plain text from this RichText.\"\"\"\n\n        if self.rich_text is None:\n            return None\n\n        return plain_text(*self.rich_text)\n</code></pre>"},{"location":"reference/types/#notional.types.RichText.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the plain text from this RichText.</p>"},{"location":"reference/types/#notional.types.RichText.__compose__","title":"<code>__compose__(*text)</code>  <code>classmethod</code>","text":"<p>Create a new <code>RichText</code> property from the given strings.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, *text):\n    \"\"\"Create a new `RichText` property from the given strings.\"\"\"\n    return cls(rich_text=rich_text(*text))\n</code></pre>"},{"location":"reference/types/#notional.types.RichText.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of object in the RichText object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of object in the RichText object.\"\"\"\n    return len(self.rich_text)\n</code></pre>"},{"location":"reference/types/#notional.types.Rollup","title":"<code>Rollup</code>","text":"<p>               Bases: <code>PropertyValue</code></p> <p>A Notion rollup property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Rollup(PropertyValue, type=\"rollup\"):\n    \"\"\"A Notion rollup property value.\"\"\"\n\n    rollup: Optional[RollupObject] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this Rollup property.\"\"\"\n\n        if self.rollup is None:\n            return \"\"\n\n        value = self.rollup.Value\n        if value is None:\n            return \"\"\n\n        return str(value)\n</code></pre>"},{"location":"reference/types/#notional.types.Rollup.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this Rollup property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this Rollup property.\"\"\"\n\n    if self.rollup is None:\n        return \"\"\n\n    value = self.rollup.Value\n    if value is None:\n        return \"\"\n\n    return str(value)\n</code></pre>"},{"location":"reference/types/#notional.types.RollupArray","title":"<code>RollupArray</code>","text":"<p>               Bases: <code>RollupObject</code></p> <p>A Notion rollup array property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class RollupArray(RollupObject, type=\"array\"):\n    \"\"\"A Notion rollup array property value.\"\"\"\n\n    array: List[PropertyValue]\n\n    @property\n    def Value(self):\n        \"\"\"Return the native representation of this Rollup object.\"\"\"\n        return self.array\n</code></pre>"},{"location":"reference/types/#notional.types.RollupArray.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the native representation of this Rollup object.</p>"},{"location":"reference/types/#notional.types.RollupDate","title":"<code>RollupDate</code>","text":"<p>               Bases: <code>RollupObject</code></p> <p>A Notion rollup date property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class RollupDate(RollupObject, type=\"date\"):\n    \"\"\"A Notion rollup date property value.\"\"\"\n\n    date: Optional[DateRange] = None\n\n    @property\n    def Value(self):\n        \"\"\"Return the native representation of this Rollup object.\"\"\"\n        return self.date\n</code></pre>"},{"location":"reference/types/#notional.types.RollupDate.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the native representation of this Rollup object.</p>"},{"location":"reference/types/#notional.types.RollupNumber","title":"<code>RollupNumber</code>","text":"<p>               Bases: <code>RollupObject</code></p> <p>A Notion rollup number property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class RollupNumber(RollupObject, type=\"number\"):\n    \"\"\"A Notion rollup number property value.\"\"\"\n\n    number: Optional[Union[float, int]] = None\n\n    @property\n    def Value(self):\n        \"\"\"Return the native representation of this Rollup object.\"\"\"\n        return self.number\n</code></pre>"},{"location":"reference/types/#notional.types.RollupNumber.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the native representation of this Rollup object.</p>"},{"location":"reference/types/#notional.types.RollupObject","title":"<code>RollupObject</code>","text":"<p>               Bases: <code>TypedObject</code>, <code>ABC</code></p> <p>A Notion rollup property value.</p> Source code in <code>src/notional/types.py</code> <pre><code>class RollupObject(TypedObject, ABC):\n    \"\"\"A Notion rollup property value.\"\"\"\n\n    function: Optional[Function] = None\n\n    @property\n    @abstractmethod\n    def Value(self):\n        \"\"\"Return the native representation of this Rollup object.\"\"\"\n</code></pre>"},{"location":"reference/types/#notional.types.RollupObject.Value","title":"<code>Value</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Return the native representation of this Rollup object.</p>"},{"location":"reference/types/#notional.types.SelectOne","title":"<code>SelectOne</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion select type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class SelectOne(NativeTypeMixin, PropertyValue, type=\"select\"):\n    \"\"\"Notion select type.\"\"\"\n\n    select: Optional[SelectValue] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return self.Value or \"\"\n\n    def __eq__(self, other):\n        \"\"\"Determine if this property is equal to the given object.\n\n        To avoid confusion, this method compares Select options by name.\n        \"\"\"\n\n        if other is None:\n            return self.select is None\n\n        return other == self.select.name\n\n    @classmethod\n    def __compose__(cls, value, color=None):\n        \"\"\"Create a `SelectOne` property from the given value.\n\n        :param value: a string to use for this property\n        :param color: an optional Color for the value\n        \"\"\"\n        return cls(select=SelectValue[value, color])\n\n    @property\n    def Value(self):\n        \"\"\"Return the value of this property as a string.\"\"\"\n\n        if self.select is None:\n            return None\n\n        return str(self.select)\n</code></pre>"},{"location":"reference/types/#notional.types.SelectOne.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the value of this property as a string.</p>"},{"location":"reference/types/#notional.types.SelectOne.__compose__","title":"<code>__compose__(value, color=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>SelectOne</code> property from the given value.</p> <p>:param value: a string to use for this property :param color: an optional Color for the value</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, value, color=None):\n    \"\"\"Create a `SelectOne` property from the given value.\n\n    :param value: a string to use for this property\n    :param color: an optional Color for the value\n    \"\"\"\n    return cls(select=SelectValue[value, color])\n</code></pre>"},{"location":"reference/types/#notional.types.SelectOne.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Determine if this property is equal to the given object.</p> <p>To avoid confusion, this method compares Select options by name.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Determine if this property is equal to the given object.\n\n    To avoid confusion, this method compares Select options by name.\n    \"\"\"\n\n    if other is None:\n        return self.select is None\n\n    return other == self.select.name\n</code></pre>"},{"location":"reference/types/#notional.types.SelectOne.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return self.Value or \"\"\n</code></pre>"},{"location":"reference/types/#notional.types.SelectValue","title":"<code>SelectValue</code>","text":"<p>               Bases: <code>GenericObject</code></p> <p>Values for select &amp; multi-select properties.</p> Source code in <code>src/notional/types.py</code> <pre><code>class SelectValue(GenericObject):\n    \"\"\"Values for select &amp; multi-select properties.\"\"\"\n\n    name: str\n    id: Optional[Union[UUID, str]] = None\n    color: Optional[Color] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return self.name\n\n    @classmethod\n    def __compose__(cls, value, color=None):\n        \"\"\"Create a `SelectValue` property from the given value.\n\n        :param value: a string to use for this property\n        :param color: an optional Color for the value\n        \"\"\"\n        return cls(name=value, color=color)\n</code></pre>"},{"location":"reference/types/#notional.types.SelectValue.__compose__","title":"<code>__compose__(value, color=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>SelectValue</code> property from the given value.</p> <p>:param value: a string to use for this property :param color: an optional Color for the value</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, value, color=None):\n    \"\"\"Create a `SelectValue` property from the given value.\n\n    :param value: a string to use for this property\n    :param color: an optional Color for the value\n    \"\"\"\n    return cls(name=value, color=color)\n</code></pre>"},{"location":"reference/types/#notional.types.SelectValue.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/types/#notional.types.Status","title":"<code>Status</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion status property.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Status(NativeTypeMixin, PropertyValue, type=\"status\"):\n    \"\"\"Notion status property.\"\"\"\n\n    class _NestedData(GenericObject):\n        name: str = None\n        id: Optional[Union[UUID, str]] = None\n        color: Optional[Color] = None\n\n    status: Optional[_NestedData] = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this property.\"\"\"\n        return self.Value or \"\"\n\n    def __eq__(self, other):\n        \"\"\"Determine if this property is equal to the given object.\n\n        To avoid confusion, this method compares Status options by name.\n        \"\"\"\n\n        if other is None:\n            return self.status is None\n\n        if isinstance(other, Status):\n            return self.status.name == other.status.name\n\n        return self.status.name == other\n\n    @classmethod\n    def __compose__(cls, name, color=None):\n        \"\"\"Create a `Status` property from the given name.\n\n        :param name: a string to use for this property\n        :param color: an optional Color for the status\n        \"\"\"\n\n        if name is None:\n            raise ValueError(\"'name' cannot be None\")\n\n        return cls(status=Status._NestedData(name=name, color=color))\n\n    @property\n    def Value(self):\n        \"\"\"Return the value of this property as a string.\"\"\"\n\n        return self.status.name\n</code></pre>"},{"location":"reference/types/#notional.types.Status.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the value of this property as a string.</p>"},{"location":"reference/types/#notional.types.Status.__compose__","title":"<code>__compose__(name, color=None)</code>  <code>classmethod</code>","text":"<p>Create a <code>Status</code> property from the given name.</p> <p>:param name: a string to use for this property :param color: an optional Color for the status</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, name, color=None):\n    \"\"\"Create a `Status` property from the given name.\n\n    :param name: a string to use for this property\n    :param color: an optional Color for the status\n    \"\"\"\n\n    if name is None:\n        raise ValueError(\"'name' cannot be None\")\n\n    return cls(status=Status._NestedData(name=name, color=color))\n</code></pre>"},{"location":"reference/types/#notional.types.Status.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Determine if this property is equal to the given object.</p> <p>To avoid confusion, this method compares Status options by name.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Determine if this property is equal to the given object.\n\n    To avoid confusion, this method compares Status options by name.\n    \"\"\"\n\n    if other is None:\n        return self.status is None\n\n    if isinstance(other, Status):\n        return self.status.name == other.status.name\n\n    return self.status.name == other\n</code></pre>"},{"location":"reference/types/#notional.types.Status.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this property.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this property.\"\"\"\n    return self.Value or \"\"\n</code></pre>"},{"location":"reference/types/#notional.types.StringFormula","title":"<code>StringFormula</code>","text":"<p>               Bases: <code>FormulaResult</code></p> <p>A Notion string formula result.</p> Source code in <code>src/notional/types.py</code> <pre><code>class StringFormula(FormulaResult, type=\"string\"):\n    \"\"\"A Notion string formula result.\"\"\"\n\n    string: Optional[str] = None\n\n    @property\n    def Result(self):\n        \"\"\"Return the result of this StringFormula.\"\"\"\n        return self.string\n</code></pre>"},{"location":"reference/types/#notional.types.StringFormula.Result","title":"<code>Result</code>  <code>property</code>","text":"<p>Return the result of this StringFormula.</p>"},{"location":"reference/types/#notional.types.Title","title":"<code>Title</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion title type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class Title(NativeTypeMixin, PropertyValue, type=\"title\"):\n    \"\"\"Notion title type.\"\"\"\n\n    title: List[RichTextObject] = []\n\n    def __len__(self):\n        \"\"\"Return the number of object in the Title object.\"\"\"\n\n        return len(self.title)\n\n    @classmethod\n    def __compose__(cls, *text):\n        \"\"\"Create a new `Title` property from the given text elements.\"\"\"\n        return cls(title=rich_text(*text))\n\n    @property\n    def Value(self):\n        \"\"\"Return the plain text from this Title.\"\"\"\n\n        if self.title is None:\n            return None\n\n        return plain_text(*self.title)\n</code></pre>"},{"location":"reference/types/#notional.types.Title.Value","title":"<code>Value</code>  <code>property</code>","text":"<p>Return the plain text from this Title.</p>"},{"location":"reference/types/#notional.types.Title.__compose__","title":"<code>__compose__(*text)</code>  <code>classmethod</code>","text":"<p>Create a new <code>Title</code> property from the given text elements.</p> Source code in <code>src/notional/types.py</code> <pre><code>@classmethod\ndef __compose__(cls, *text):\n    \"\"\"Create a new `Title` property from the given text elements.\"\"\"\n    return cls(title=rich_text(*text))\n</code></pre>"},{"location":"reference/types/#notional.types.Title.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of object in the Title object.</p> Source code in <code>src/notional/types.py</code> <pre><code>def __len__(self):\n    \"\"\"Return the number of object in the Title object.\"\"\"\n\n    return len(self.title)\n</code></pre>"},{"location":"reference/types/#notional.types.URL","title":"<code>URL</code>","text":"<p>               Bases: <code>NativeTypeMixin</code>, <code>PropertyValue</code></p> <p>Notion URL type.</p> Source code in <code>src/notional/types.py</code> <pre><code>class URL(NativeTypeMixin, PropertyValue, type=\"url\"):\n    \"\"\"Notion URL type.\"\"\"\n\n    url: Optional[str] = None\n</code></pre>"},{"location":"reference/types/#notional.types.WorkspaceRef","title":"<code>WorkspaceRef</code>","text":"<p>               Bases: <code>ParentRef</code></p> <p>Reference the workspace.</p> Source code in <code>src/notional/types.py</code> <pre><code>class WorkspaceRef(ParentRef, type=\"workspace\"):\n    \"\"\"Reference the workspace.\"\"\"\n\n    workspace: bool = True\n</code></pre>"},{"location":"reference/user/","title":"User","text":"<p>Wrapper for Notion user objects.</p>"},{"location":"reference/user/#notional.user.Bot","title":"<code>Bot</code>","text":"<p>               Bases: <code>User</code></p> <p>Represents a Bot in Notion.</p> Source code in <code>src/notional/user.py</code> <pre><code>class Bot(User):\n    \"\"\"Represents a Bot in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        pass\n\n    bot: _NestedData = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this `Bot`.\"\"\"\n        return f\"[%{self.name}]\"\n</code></pre>"},{"location":"reference/user/#notional.user.Bot.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this <code>Bot</code>.</p> Source code in <code>src/notional/user.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this `Bot`.\"\"\"\n    return f\"[%{self.name}]\"\n</code></pre>"},{"location":"reference/user/#notional.user.Person","title":"<code>Person</code>","text":"<p>               Bases: <code>User</code></p> <p>Represents a Person in Notion.</p> Source code in <code>src/notional/user.py</code> <pre><code>class Person(User):\n    \"\"\"Represents a Person in Notion.\"\"\"\n\n    class _NestedData(GenericObject):\n        email: str\n\n    person: _NestedData = None\n\n    def __str__(self):\n        \"\"\"Return a string representation of this `Person`.\"\"\"\n        return f\"[@{self.name}]\"\n</code></pre>"},{"location":"reference/user/#notional.user.Person.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of this <code>Person</code>.</p> Source code in <code>src/notional/user.py</code> <pre><code>def __str__(self):\n    \"\"\"Return a string representation of this `Person`.\"\"\"\n    return f\"[@{self.name}]\"\n</code></pre>"},{"location":"reference/user/#notional.user.User","title":"<code>User</code>","text":"<p>               Bases: <code>NotionObject</code></p> <p>Represents a User in Notion.</p> Source code in <code>src/notional/user.py</code> <pre><code>class User(NotionObject, object=\"user\"):\n    \"\"\"Represents a User in Notion.\"\"\"\n\n    # XXX why isn't this a TypedObject ?\n\n    type: Optional[UserType] = None\n    name: Optional[str] = None\n    avatar_url: Optional[str] = None\n\n    @classmethod\n    def parse_obj(cls, obj):\n        \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\"\n\n        if obj is None:\n            return None\n\n        if \"type\" in obj:\n            if obj[\"type\"] == \"person\":\n                return Person(**obj)\n\n            if obj[\"type\"] == \"bot\":\n                return Bot(**obj)\n\n        return cls(obj)\n</code></pre>"},{"location":"reference/user/#notional.user.User.parse_obj","title":"<code>parse_obj(obj)</code>  <code>classmethod</code>","text":"<p>Attempt to parse the given object data into the correct <code>User</code> type.</p> Source code in <code>src/notional/user.py</code> <pre><code>@classmethod\ndef parse_obj(cls, obj):\n    \"\"\"Attempt to parse the given object data into the correct `User` type.\"\"\"\n\n    if obj is None:\n        return None\n\n    if \"type\" in obj:\n        if obj[\"type\"] == \"person\":\n            return Person(**obj)\n\n        if obj[\"type\"] == \"bot\":\n            return Bot(**obj)\n\n    return cls(obj)\n</code></pre>"},{"location":"reference/user/#notional.user.UserType","title":"<code>UserType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Available user types.</p> Source code in <code>src/notional/user.py</code> <pre><code>class UserType(str, Enum):\n    \"\"\"Available user types.\"\"\"\n\n    PERSON = \"person\"\n    BOT = \"bot\"\n</code></pre>"}]}